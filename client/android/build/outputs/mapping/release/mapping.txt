# compiler: R8
# compiler_version: 4.0.48
# min_api: 26
# common_typos_disable
# {"id":"com.android.tools.r8.mapping","version":"2.1"}
# pg_map_id: bdf9e3a
# pg_map_hash: SHA-256 bdf9e3ab104a56b638769a4c2109fe7eeeca36f4537a78391eeb91383754b954
androidx.collection.ArrayMap -> a.a:
    androidx.collection.MapCollections mCollections -> k
    androidx.collection.MapCollections getCollection() -> m
androidx.collection.ArrayMap$1 -> a.a$a:
    androidx.collection.ArrayMap this$0 -> d
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> b
    java.util.Map colGetMap() -> c
    int colGetSize() -> d
    int colIndexOfKey(java.lang.Object) -> e
    int colIndexOfValue(java.lang.Object) -> f
    void colPut(java.lang.Object,java.lang.Object) -> g
    void colRemoveAt(int) -> h
    java.lang.Object colSetValue(int,java.lang.Object) -> i
androidx.collection.ContainerHelpers -> a.b:
    java.lang.Object[] EMPTY_OBJECTS -> c
    long[] EMPTY_LONGS -> b
    int[] EMPTY_INTS -> a
    int binarySearch(int[],int,int) -> a
    boolean equal(java.lang.Object,java.lang.Object) -> b
androidx.collection.MapCollections -> a.c:
    androidx.collection.MapCollections$KeySet mKeySet -> b
    androidx.collection.MapCollections$ValuesCollection mValues -> c
    androidx.collection.MapCollections$EntrySet mEntrySet -> a
    void colClear() -> a
    java.lang.Object colGetEntry(int,int) -> b
    java.util.Map colGetMap() -> c
    int colGetSize() -> d
    int colIndexOfKey(java.lang.Object) -> e
    int colIndexOfValue(java.lang.Object) -> f
    void colPut(java.lang.Object,java.lang.Object) -> g
    void colRemoveAt(int) -> h
    java.lang.Object colSetValue(int,java.lang.Object) -> i
    boolean containsAllHelper(java.util.Map,java.util.Collection) -> j
    boolean equalsSetHelper(java.util.Set,java.lang.Object) -> k
    java.util.Set getEntrySet() -> l
    java.util.Set getKeySet() -> m
    java.util.Collection getValues() -> n
    boolean removeAllHelper(java.util.Map,java.util.Collection) -> o
    boolean retainAllHelper(java.util.Map,java.util.Collection) -> p
    java.lang.Object[] toArrayHelper(int) -> q
    java.lang.Object[] toArrayHelper(java.lang.Object[],int) -> r
androidx.collection.MapCollections$ArrayIterator -> a.c$a:
    androidx.collection.MapCollections this$0 -> h
    int mIndex -> f
    int mOffset -> d
    boolean mCanRemove -> g
    int mSize -> e
androidx.collection.MapCollections$EntrySet -> a.c$b:
    androidx.collection.MapCollections this$0 -> d
    boolean add(java.util.Map$Entry) -> a
androidx.collection.MapCollections$KeySet -> a.c$c:
    androidx.collection.MapCollections this$0 -> d
androidx.collection.MapCollections$MapIterator -> a.c$d:
    androidx.collection.MapCollections this$0 -> g
    boolean mEntryValid -> f
    int mEnd -> d
    int mIndex -> e
    java.util.Map$Entry next() -> a
androidx.collection.MapCollections$ValuesCollection -> a.c$e:
    androidx.collection.MapCollections this$0 -> d
androidx.collection.SimpleArrayMap -> a.d:
    java.lang.Object[] mArray -> e
    int mTwiceBaseCacheSize -> j
    int[] mHashes -> d
    int mBaseCacheSize -> h
    int mSize -> f
    java.lang.Object[] mTwiceBaseCache -> i
    java.lang.Object[] mBaseCache -> g
    void allocArrays(int) -> a
    int binarySearchHashes(int[],int,int) -> b
    void ensureCapacity(int) -> c
    void freeArrays(int[],java.lang.Object[],int) -> d
    int indexOf(java.lang.Object,int) -> e
    int indexOfKey(java.lang.Object) -> f
    int indexOfNull() -> g
    int indexOfValue(java.lang.Object) -> h
    java.lang.Object keyAt(int) -> i
    java.lang.Object removeAt(int) -> j
    java.lang.Object setValueAt(int,java.lang.Object) -> k
    java.lang.Object valueAt(int) -> l
androidx.core.app.CoreComponentFactory -> androidx.core.app.CoreComponentFactory:
    java.lang.Object checkCompatWrapper(java.lang.Object) -> a
androidx.core.app.CoreComponentFactory$CompatWrapped -> androidx.core.app.CoreComponentFactory$a:
    java.lang.Object getWrapper() -> a
androidx.core.app.RemoteActionCompat -> androidx.core.app.RemoteActionCompat:
    androidx.core.graphics.drawable.IconCompat mIcon -> a
    java.lang.CharSequence mTitle -> b
    java.lang.CharSequence mContentDescription -> c
    boolean mEnabled -> e
    boolean mShouldShowIcon -> f
    android.app.PendingIntent mActionIntent -> d
androidx.core.graphics.drawable.IconCompat -> androidx.core.graphics.drawable.IconCompat:
    java.lang.String mTintModeStr -> i
    android.graphics.PorterDuff$Mode DEFAULT_TINT_MODE -> k
    java.lang.String mString1 -> j
    android.graphics.PorterDuff$Mode mTintMode -> h
    android.os.Parcelable mParcelable -> d
    java.lang.Object mObj1 -> b
    int mInt2 -> f
    android.content.res.ColorStateList mTintList -> g
    int mInt1 -> e
    byte[] mData -> c
    int mType -> a
    int getResId() -> a
    java.lang.String getResPackage() -> b
    android.net.Uri getUri() -> c
    java.io.InputStream getUriInputStream(android.content.Context) -> d
    void onPostParceling() -> e
    void onPreParceling(boolean) -> f
    java.lang.String typeToString(int) -> g
androidx.core.graphics.drawable.IconCompat$Api23Impl -> androidx.core.graphics.drawable.IconCompat$a:
    int getResId(java.lang.Object) -> a
    java.lang.String getResPackage(java.lang.Object) -> b
    android.net.Uri getUri(java.lang.Object) -> c
    android.graphics.drawable.Drawable loadDrawable(android.graphics.drawable.Icon,android.content.Context) -> d
    android.graphics.drawable.Icon toIcon(androidx.core.graphics.drawable.IconCompat,android.content.Context) -> e
androidx.core.graphics.drawable.IconCompat$Api26Impl -> androidx.core.graphics.drawable.IconCompat$b:
    android.graphics.drawable.Drawable createAdaptiveIconDrawable(android.graphics.drawable.Drawable,android.graphics.drawable.Drawable) -> a
    android.graphics.drawable.Icon createWithAdaptiveBitmap(android.graphics.Bitmap) -> b
androidx.core.graphics.drawable.IconCompat$Api28Impl -> androidx.core.graphics.drawable.IconCompat$c:
    int getResId(java.lang.Object) -> a
    java.lang.String getResPackage(java.lang.Object) -> b
    int getType(java.lang.Object) -> c
    android.net.Uri getUri(java.lang.Object) -> d
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline0 -> androidx.core.graphics.drawable.a:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$0cc1fb17db561c5ba334428991ab275abe874bc3f63f42e6ae00a455df2f29af$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline1 -> androidx.core.graphics.drawable.b:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.net.Uri androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$1d5cd78ab5bc2ba7c5847bdfe6baf67c823a02789768df43e179f05a9e3c22c3$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline2 -> androidx.core.graphics.drawable.c:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$40b39641b9d6ef68de58f9b92a6906fe9b99705bdf062dc89a3ea0a21d65018d$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api28Impl$$ExternalSyntheticApiModelOutline3 -> androidx.core.graphics.drawable.d:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    java.lang.String androidx.core.graphics.drawable.IconCompat$Api28Impl$$InternalSyntheticApiModelOutline$1$425daee209e8ac6dbaf4d4161c4994372512a53b633026f0a72c7baf9f5b568e$0.m(android.graphics.drawable.Icon) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.core.graphics.drawable.IconCompat$Api30Impl -> androidx.core.graphics.drawable.IconCompat$d:
    android.graphics.drawable.Icon createWithAdaptiveBitmapContentUri(android.net.Uri) -> a
androidx.core.graphics.drawable.IconCompat$Api30Impl$$ExternalSyntheticApiModelOutline0 -> androidx.core.graphics.drawable.e:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.graphics.drawable.Icon androidx.core.graphics.drawable.IconCompat$Api30Impl$$InternalSyntheticApiModelOutline$1$181d250257b606f3a0952ed61d731be99dd28d4f22e07105279bf0946c8d21f1$0.m(android.net.Uri) -> a
      # {"id":"com.android.tools.r8.synthesized"}
androidx.lifecycle.LiveData$ObserverWrapper -> androidx.lifecycle.a:
androidx.savedstate.Recreator -> androidx.savedstate.Recreator:
    androidx.savedstate.Recreator$Companion Companion -> a
androidx.savedstate.Recreator$Companion -> androidx.savedstate.Recreator$a:
androidx.versionedparcelable.ParcelImpl -> androidx.versionedparcelable.ParcelImpl:
    androidx.versionedparcelable.VersionedParcelable mParcel -> d
androidx.versionedparcelable.ParcelImpl$1 -> androidx.versionedparcelable.ParcelImpl$a:
    androidx.versionedparcelable.ParcelImpl createFromParcel(android.os.Parcel) -> a
    androidx.versionedparcelable.ParcelImpl[] newArray(int) -> b
androidx.versionedparcelable.VersionedParcel -> androidx.versionedparcelable.a:
    androidx.collection.ArrayMap mParcelizerCache -> c
    androidx.collection.ArrayMap mReadCache -> a
    androidx.collection.ArrayMap mWriteCache -> b
    void writeByteArray(byte[]) -> A
    void writeByteArray(byte[],int) -> B
    void writeCharSequence(java.lang.CharSequence) -> C
    void writeCharSequence(java.lang.CharSequence,int) -> D
    void writeInt(int) -> E
    void writeInt(int,int) -> F
    void writeParcelable(android.os.Parcelable) -> G
    void writeParcelable(android.os.Parcelable,int) -> H
    void writeString(java.lang.String) -> I
    void writeString(java.lang.String,int) -> J
    void writeToParcel(androidx.versionedparcelable.VersionedParcelable,androidx.versionedparcelable.VersionedParcel) -> K
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable) -> L
    void writeVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> M
    void writeVersionedParcelableCreator(androidx.versionedparcelable.VersionedParcelable) -> N
    void closeField() -> a
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> b
    java.lang.Class findParcelClass(java.lang.Class) -> c
    java.lang.reflect.Method getReadMethod(java.lang.String) -> d
    java.lang.reflect.Method getWriteMethod(java.lang.Class) -> e
    boolean isStream() -> f
    boolean readBoolean() -> g
    boolean readBoolean(boolean,int) -> h
    byte[] readByteArray() -> i
    byte[] readByteArray(byte[],int) -> j
    java.lang.CharSequence readCharSequence() -> k
    java.lang.CharSequence readCharSequence(java.lang.CharSequence,int) -> l
    boolean readField(int) -> m
    androidx.versionedparcelable.VersionedParcelable readFromParcel(java.lang.String,androidx.versionedparcelable.VersionedParcel) -> n
    int readInt() -> o
    int readInt(int,int) -> p
    android.os.Parcelable readParcelable() -> q
    android.os.Parcelable readParcelable(android.os.Parcelable,int) -> r
    java.lang.String readString() -> s
    java.lang.String readString(java.lang.String,int) -> t
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable() -> u
    androidx.versionedparcelable.VersionedParcelable readVersionedParcelable(androidx.versionedparcelable.VersionedParcelable,int) -> v
    void setOutputField(int) -> w
    void setSerializationFlags(boolean,boolean) -> x
    void writeBoolean(boolean) -> y
    void writeBoolean(boolean,int) -> z
androidx.versionedparcelable.VersionedParcelParcel -> androidx.versionedparcelable.b:
    android.util.SparseIntArray mPositionLookup -> d
    java.lang.String mPrefix -> h
    int mNextRead -> j
    android.os.Parcel mParcel -> e
    int mFieldId -> k
    int mCurrentField -> i
    int mOffset -> f
    int mEnd -> g
    void writeByteArray(byte[]) -> A
    void writeCharSequence(java.lang.CharSequence) -> C
    void writeInt(int) -> E
    void writeParcelable(android.os.Parcelable) -> G
    void writeString(java.lang.String) -> I
    void closeField() -> a
    androidx.versionedparcelable.VersionedParcel createSubParcel() -> b
    boolean readBoolean() -> g
    byte[] readByteArray() -> i
    java.lang.CharSequence readCharSequence() -> k
    boolean readField(int) -> m
    int readInt() -> o
    android.os.Parcelable readParcelable() -> q
    java.lang.String readString() -> s
    void setOutputField(int) -> w
    void writeBoolean(boolean) -> y
androidx.versionedparcelable.VersionedParcelable -> b.a:
com.badlogic.gdx.AbstractGraphics -> c.a:
com.badlogic.gdx.AbstractInput -> c.b:
    com.badlogic.gdx.utils.IntSet keysToCatch -> c
    boolean[] pressedKeys -> a
    boolean keyJustPressed -> e
    boolean[] justPressedKeys -> b
    int pressedKeyCount -> d
    boolean isKeyPressed(int) -> b
    boolean isCatchBackKey() -> c
    boolean isCatchKey(int) -> j
    void setCatchKey(int,boolean) -> k
com.badlogic.gdx.Application -> c.c:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    com.badlogic.gdx.Application$ApplicationType getType() -> d
    void debug(java.lang.String,java.lang.String) -> e
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> f
    void log(java.lang.String,java.lang.String) -> g
    void setLogLevel(int) -> i
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> j
    void postRunnable(java.lang.Runnable) -> k
    int getVersion() -> m
    com.badlogic.gdx.Graphics getGraphics() -> o
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> p
com.badlogic.gdx.Application$ApplicationType -> c.c$a:
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> j
    com.badlogic.gdx.Application$ApplicationType iOS -> i
    com.badlogic.gdx.Application$ApplicationType WebGL -> h
    com.badlogic.gdx.Application$ApplicationType Desktop -> e
    com.badlogic.gdx.Application$ApplicationType Android -> d
    com.badlogic.gdx.Application$ApplicationType Applet -> g
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> f
com.badlogic.gdx.ApplicationListener -> c.d:
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    void resize(int,int) -> d
    void create() -> e
    void render() -> f
com.badlogic.gdx.ApplicationLogger -> c.e:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void debug(java.lang.String,java.lang.String) -> e
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> f
    void log(java.lang.String,java.lang.String) -> g
com.badlogic.gdx.Audio -> c.f:
com.badlogic.gdx.Files -> c.g:
com.badlogic.gdx.Game -> c.h:
    com.badlogic.gdx.Screen screen -> a
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render() -> f
    void setScreen(com.badlogic.gdx.Screen) -> g
com.badlogic.gdx.Gdx -> c.i:
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.graphics.GL30 gl30 -> i
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    com.badlogic.gdx.graphics.GL20 gl -> g
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
com.badlogic.gdx.Graphics -> c.j:
    int getWidth() -> c
    int getHeight() -> d
    int getBackBufferWidth() -> e
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> f
    float getDeltaTime() -> g
    int getBackBufferHeight() -> h
    boolean supportsExtension(java.lang.String) -> i
    void requestRendering() -> j
    boolean isGL30Available() -> k
com.badlogic.gdx.Graphics$BufferFormat -> c.j$a:
    int stencil -> f
    int samples -> g
    int a -> d
    int depth -> e
    boolean coverageSampling -> h
    int g -> b
    int b -> c
    int r -> a
com.badlogic.gdx.Graphics$DisplayMode -> c.j$b:
    int bitsPerPixel -> d
    int height -> b
    int refreshRate -> c
    int width -> a
com.badlogic.gdx.Input -> c.k:
    boolean justTouched() -> a
    boolean isKeyPressed(int) -> b
    boolean isCatchBackKey() -> c
com.badlogic.gdx.Input$OnscreenKeyboardType -> c.k$a:
    com.badlogic.gdx.Input$OnscreenKeyboardType Email -> g
    com.badlogic.gdx.Input$OnscreenKeyboardType[] $VALUES -> j
    com.badlogic.gdx.Input$OnscreenKeyboardType PhonePad -> f
    com.badlogic.gdx.Input$OnscreenKeyboardType URI -> i
    com.badlogic.gdx.Input$OnscreenKeyboardType Password -> h
    com.badlogic.gdx.Input$OnscreenKeyboardType NumberPad -> e
    com.badlogic.gdx.Input$OnscreenKeyboardType Default -> d
com.badlogic.gdx.Input$Orientation -> c.k$b:
    com.badlogic.gdx.Input$Orientation Portrait -> e
    com.badlogic.gdx.Input$Orientation Landscape -> d
    com.badlogic.gdx.Input$Orientation[] $VALUES -> f
com.badlogic.gdx.LifecycleListener -> c.l:
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.Net -> c.m:
com.badlogic.gdx.Screen -> c.n:
    void pause() -> a
    void show() -> b
    void resume() -> c
    void resize(int,int) -> d
    void render(float) -> e
    void hide() -> f
com.badlogic.gdx.backends.android.AndroidApplication -> d.a:
    int logLevel -> n
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    boolean useImmersiveMode -> p
    boolean firstResume -> i
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.utils.SnapshotArray lifecycleListeners -> l
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    boolean isWaitingForAudio -> r
    com.badlogic.gdx.utils.Array androidEventListeners -> m
    com.badlogic.gdx.ApplicationLogger applicationLogger -> o
    com.badlogic.gdx.utils.Array executedRunnables -> k
    com.badlogic.gdx.utils.Array runnables -> j
    com.badlogic.gdx.ApplicationListener listener -> g
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> f
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    android.os.Handler handler -> h
    int wasFocusChanged -> q
    com.badlogic.gdx.Files getFiles() -> A
    com.badlogic.gdx.Net getNet() -> B
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> C
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> D
    void setApplicationLogger(com.badlogic.gdx.ApplicationLogger) -> E
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    android.content.Context getContext() -> c
    com.badlogic.gdx.Application$ApplicationType getType() -> d
    void debug(java.lang.String,java.lang.String) -> e
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> f
    void log(java.lang.String,java.lang.String) -> g
    com.badlogic.gdx.utils.Array getRunnables() -> h
    void setLogLevel(int) -> i
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> j
    void postRunnable(java.lang.Runnable) -> k
    void useImmersiveMode(boolean) -> l
    int getVersion() -> m
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> n
    com.badlogic.gdx.Graphics getGraphics() -> o
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> p
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> q
    android.view.Window getApplicationWindow() -> r
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> s
    com.badlogic.gdx.backends.android.AndroidAudio createAudio(android.content.Context,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> t
    com.badlogic.gdx.backends.android.AndroidFiles createFiles() -> u
    com.badlogic.gdx.backends.android.AndroidInput createInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> v
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> w
    void createWakeLock(boolean) -> x
    com.badlogic.gdx.ApplicationLogger getApplicationLogger() -> y
    com.badlogic.gdx.Audio getAudio() -> z
com.badlogic.gdx.backends.android.AndroidApplication$1 -> d.a$a:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.backends.android.AndroidApplicationBase -> d.b:
    android.content.Context getContext() -> c
    com.badlogic.gdx.utils.Array getRunnables() -> h
    void useImmersiveMode(boolean) -> l
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> n
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> q
    android.view.Window getApplicationWindow() -> r
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> s
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> d.c:
    boolean useWakelock -> n
    int sensorDelay -> l
    boolean disableAudio -> o
    int touchSleepTime -> m
    boolean useGyroscope -> i
    boolean useCompass -> j
    boolean useRotationVectorSensor -> k
    int stencil -> f
    int numSamples -> g
    int a -> d
    int depth -> e
    int g -> b
    int b -> c
    boolean getTouchEventsForLiveWallpaper -> r
    com.badlogic.gdx.backends.android.GdxNativeLoader nativeLoader -> v
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> q
    boolean useImmersiveMode -> s
    int r -> a
    boolean useGL30 -> t
    boolean useAccelerometer -> h
    int maxNetThreads -> u
    int maxSimultaneousSounds -> p
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration$1 -> d.c$a:
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration this$0 -> a
    void load() -> a
com.badlogic.gdx.backends.android.AndroidApplicationLogger -> d.d:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> a
    void error(java.lang.String,java.lang.String) -> b
    void debug(java.lang.String,java.lang.String) -> e
    void error(java.lang.String,java.lang.String,java.lang.Throwable) -> f
    void log(java.lang.String,java.lang.String) -> g
com.badlogic.gdx.backends.android.AndroidAudio -> d.e:
    void pause() -> a
    void resume() -> c
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> d
com.badlogic.gdx.backends.android.AndroidClipboard -> d.f:
    android.content.ClipboardManager clipboard -> a
com.badlogic.gdx.backends.android.AndroidEventListener -> d.g:
    void onActivityResult(int,int,android.content.Intent) -> a
com.badlogic.gdx.backends.android.AndroidFiles -> d.h:
com.badlogic.gdx.backends.android.AndroidGL20 -> d.i:
    int[] ints2 -> b
    int[] ints3 -> c
    int[] ints -> a
    byte[] buffer -> d
    void glGenerateMipmap(int) -> a
    void glLinkProgram(int) -> b
    void glTexParameteri(int,int,int) -> c
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> d
    int glGenFramebuffer() -> e
    java.lang.String glGetProgramInfoLog(int) -> f
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> g
    void glGetFloatv(int,java.nio.FloatBuffer) -> i
    void glShaderSource(int,java.lang.String) -> j
    void glAttachShader(int,int) -> k
    java.lang.String glGetShaderInfoLog(int) -> l
    void glCompileShader(int) -> m
    void glBindFramebuffer(int,int) -> n
    int glGenTexture() -> o
    int glCreateProgram() -> p
    int glCreateShader(int) -> q
com.badlogic.gdx.backends.android.AndroidGL30 -> d.j:
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> h
com.badlogic.gdx.backends.android.AndroidGraphics -> d.p:
    com.badlogic.gdx.graphics.GL30 gl30 -> j
    com.badlogic.gdx.graphics.GL20 gl20 -> i
    int safeInsetBottom -> f
    boolean running -> u
    int safeInsetLeft -> d
    boolean resume -> w
    float ppcY -> B
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> E
    int width -> b
    com.badlogic.gdx.graphics.glutils.GLVersion glVersion -> l
    int[] value -> G
    float ppiX -> y
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> h
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> D
    long frameId -> q
    float deltaTime -> o
    int fps -> s
    java.lang.Object synch -> H
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 view -> a
    boolean enforceContinuousRendering -> I
    java.lang.String extensions -> m
    int safeInsetRight -> g
    boolean pause -> v
    float density -> C
    int safeInsetTop -> e
    boolean destroy -> x
    float ppcX -> A
    int height -> c
    boolean created -> t
    float ppiY -> z
    javax.microedition.khronos.egl.EGLContext eglContext -> k
    boolean isContinuous -> F
    long lastFrameTime -> n
    int frames -> r
    long frameStart -> p
    void updatePpi() -> A
    void updateSafeAreaInsets() -> B
    boolean checkGL20() -> a
    void clearManagedCaches() -> b
    int getWidth() -> c
    int getHeight() -> d
    int getBackBufferWidth() -> e
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> f
    float getDeltaTime() -> g
    int getBackBufferHeight() -> h
    boolean supportsExtension(java.lang.String) -> i
    void requestRendering() -> j
    boolean isGL30Available() -> k
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> l
    void destroy() -> m
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> n
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> o
    android.view.View getView() -> p
    boolean isContinuousRendering() -> q
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> r
    void logManagedCachesStatus() -> s
    void onPauseGLSurfaceView() -> t
    void onResumeGLSurfaceView() -> u
    void pause() -> v
    void preserveEGLContextOnPause() -> w
    void resume() -> x
    void setContinuousRendering(boolean) -> y
    void setupGL(javax.microedition.khronos.opengles.GL10) -> z
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline0 -> d.k:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    android.view.DisplayCutout com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$0.m(android.view.WindowInsets) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline1 -> d.l:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$1.m(android.view.DisplayCutout) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline2 -> d.m:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$2.m(android.view.DisplayCutout) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline3 -> d.n:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$3.m(android.view.DisplayCutout) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$$ExternalSyntheticApiModelOutline4 -> d.o:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    int com.badlogic.gdx.backends.android.AndroidGraphics$$InternalSyntheticApiModelOutline$1$7cdcf504b3e93db3bfde1912e3682440b9fc2bf91261ad91ae7fc555763f5b1e$4.m(android.view.DisplayCutout) -> a
      # {"id":"com.android.tools.r8.synthesized"}
com.badlogic.gdx.backends.android.AndroidGraphics$1 -> d.p$a:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> d
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> d.p$b:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidHaptics -> d.q:
    android.os.Vibrator vibrator -> a
    boolean vibratorSupport -> c
    android.media.AudioAttributes audioAttributes -> b
    boolean hapticsSupport -> d
com.badlogic.gdx.backends.android.AndroidInput -> d.r:
    void addKeyListener(android.view.View$OnKeyListener) -> d
    void onResume() -> e
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> f
    void setKeyboardAvailable(boolean) -> g
    void onPause() -> h
    void processEvents() -> i
com.badlogic.gdx.backends.android.AndroidMouseHandler -> d.s:
    int deltaY -> b
    int deltaX -> a
    boolean onGenericMotion(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
com.badlogic.gdx.backends.android.AndroidMusic -> d.t:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> a
    android.media.MediaPlayer player -> b
    boolean isPrepared -> c
    boolean wasPlaying -> d
    void pause() -> a
    void dispose() -> b
    boolean isPlaying() -> e
    void play() -> f
com.badlogic.gdx.backends.android.AndroidNet -> d.u:
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> a
com.badlogic.gdx.backends.android.AndroidTouchHandler -> d.v:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
    boolean supportsMultitouch(android.content.Context) -> c
    int toGdxButton(int) -> d
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> d.w:
    void createListener(com.badlogic.gdx.backends.android.AndroidApplicationBase) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 -> d.w$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener this$0 -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase val$application -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1$1 -> d.w$a$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 this$1 -> d
com.badlogic.gdx.backends.android.DefaultAndroidAudio -> d.x:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    java.util.List musics -> c
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> d
com.badlogic.gdx.backends.android.DefaultAndroidFiles -> d.y:
    android.content.res.AssetManager assets -> c
    java.lang.String externalFilesPath -> a
    java.lang.String localpath -> b
    java.lang.String initExternalFilesPath(android.content.ContextWrapper) -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput -> d.z:
    float pitch -> L
    boolean justTouched -> N
    android.content.Context context -> B
    float[] magneticFieldValues -> I
    boolean[] touched -> o
    boolean requestFocus -> X
    android.hardware.SensorEventListener gyroscopeListener -> S
    boolean hasMultitouch -> s
    android.hardware.SensorEventListener rotationVectorListener -> U
    float[] R -> Y
    java.util.ArrayList keyEvents -> i
    int[] deltaY -> n
    java.util.ArrayList genericMotionListeners -> V
    int[] button -> p
    boolean rotationVectorAvailable -> G
    com.badlogic.gdx.utils.Pool usedKeyEvents -> f
    float[] pressure -> r
    int[] touchY -> l
    float azimuth -> K
    float[] rotationVectorValues -> J
    boolean[] justPressedButtons -> t
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> C
    boolean accelerometerAvailable -> v
    int sleepTime -> D
    boolean gyroscopeAvailable -> x
    com.badlogic.gdx.Application app -> A
    android.hardware.SensorEventListener accelerometerListener -> R
    android.os.Handler handle -> z
    android.hardware.SensorEventListener compassListener -> T
    float[] gyroscopeValues -> y
    java.util.ArrayList touchEvents -> j
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> O
    float[] orientation -> Z
    float[] accelerometerValues -> w
    java.util.ArrayList keyListeners -> h
    android.hardware.SensorManager manager -> u
    boolean compassAvailable -> F
    long currentEventTimeStamp -> Q
    int[] realId -> q
    boolean keyboardAvailable -> H
    com.badlogic.gdx.backends.android.AndroidHaptics haptics -> E
    int[] touchX -> k
    com.badlogic.gdx.Input$Orientation nativeOrientation -> P
    com.badlogic.gdx.utils.Pool usedTouchEvents -> g
    com.badlogic.gdx.backends.android.AndroidMouseHandler mouseHandler -> W
    int[] deltaX -> m
    float roll -> M
    boolean justTouched() -> a
    void addKeyListener(android.view.View$OnKeyListener) -> d
    void onResume() -> e
    void addGenericMotionListener(android.view.View$OnGenericMotionListener) -> f
    void setKeyboardAvailable(boolean) -> g
    void onPause() -> h
    void processEvents() -> i
    int getAndroidInputType(com.badlogic.gdx.Input$OnscreenKeyboardType) -> l
    int getFreePointerIndex() -> m
    int getRotation() -> n
    boolean isCursorCatched() -> o
    int lookUpPointerIndex(int) -> p
    void registerSensorListeners() -> q
    float[] resize(float[]) -> r
    int[] resize(int[]) -> s
    boolean[] resize(boolean[]) -> t
    void unregisterSensorListeners() -> u
com.badlogic.gdx.backends.android.DefaultAndroidInput$1 -> d.z$a:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$2 -> d.z$b:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$6 -> d.z$c:
    int[] $SwitchMap$com$badlogic$gdx$Input$OnscreenKeyboardType -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent -> d.z$d:
    long timeStamp -> a
    int type -> b
    char keyChar -> d
    int keyCode -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$SensorListener -> d.z$e:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent -> d.z$f:
    int pointer -> h
    int scrollAmountY -> f
    long timeStamp -> a
    int button -> g
    int y -> d
    int scrollAmountX -> e
    int type -> b
    int x -> c
com.badlogic.gdx.backends.android.GdxNativeLoader -> d.a0:
    void load() -> a
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> e.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> e.b:
    int targetGLESVersion -> d
    java.lang.String TAG -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType onscreenKeyboardType -> b
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
    boolean checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
    void init(boolean,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> e.b$a:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> e.b$b:
    int[] mValue -> g
    int[] s_configAttribs2 -> h
    int mStencilSize -> f
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> e.b$c:
    int EGL_CONTEXT_CLIENT_VERSION -> a
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> e.c:
    int[] mConfigAttribs -> h
    int[] mValue -> i
    int mStencilSize -> f
    int mNumSamples -> g
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> e.d:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> e.d$a:
    int height -> b
    int width -> a
com.badlogic.gdx.controllers.AbstractControllerManager -> f.a:
    com.badlogic.gdx.utils.Array controllers -> a
    com.badlogic.gdx.controllers.Controller currentController -> b
    com.badlogic.gdx.controllers.Controller access$000(com.badlogic.gdx.controllers.AbstractControllerManager) -> j
    com.badlogic.gdx.controllers.Controller access$002(com.badlogic.gdx.controllers.AbstractControllerManager,com.badlogic.gdx.controllers.Controller) -> k
com.badlogic.gdx.controllers.AbstractControllerManager$ManageCurrentControllerListener -> f.a$a:
    com.badlogic.gdx.controllers.AbstractControllerManager this$0 -> a
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> b
    void disconnected(com.badlogic.gdx.controllers.Controller) -> c
    void connected(com.badlogic.gdx.controllers.Controller) -> d
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> e
com.badlogic.gdx.controllers.Controller -> f.b:
com.badlogic.gdx.controllers.ControllerAdapter -> f.c:
com.badlogic.gdx.controllers.ControllerListener -> f.d:
    boolean axisMoved(com.badlogic.gdx.controllers.Controller,int,float) -> a
    boolean buttonUp(com.badlogic.gdx.controllers.Controller,int) -> b
    void disconnected(com.badlogic.gdx.controllers.Controller) -> c
    void connected(com.badlogic.gdx.controllers.Controller) -> d
    boolean buttonDown(com.badlogic.gdx.controllers.Controller,int) -> e
com.badlogic.gdx.controllers.android.AndroidController -> com.badlogic.gdx.controllers.android.a:
    com.badlogic.gdx.utils.IntIntMap buttons -> c
    float povY -> g
    java.lang.String uuid -> j
    float povX -> f
    boolean connected -> k
    int[] axesIds -> e
    float[] axes -> d
    boolean povAxis -> h
    com.badlogic.gdx.utils.Array listeners -> i
    java.lang.String name -> b
    int deviceId -> a
    float getAxis(int) -> a
    boolean getButton(int) -> b
    com.badlogic.gdx.utils.Array getListeners() -> c
    java.lang.String getName() -> d
    boolean hasPovAxis() -> e
com.badlogic.gdx.controllers.android.AndroidControllerEvent -> com.badlogic.gdx.controllers.android.b:
    float axisValue -> d
    int type -> b
    int code -> c
    com.badlogic.gdx.controllers.android.AndroidController controller -> a
com.badlogic.gdx.controllers.android.AndroidControllers -> com.badlogic.gdx.controllers.android.AndroidControllers:
    com.badlogic.gdx.utils.Array eventQueue -> e
    com.badlogic.gdx.utils.Array listeners -> d
    boolean ignoreNoGamepadButtons -> g
    com.badlogic.gdx.utils.Pool eventPool -> f
    com.badlogic.gdx.utils.IntMap controllerMap -> c
    void pause() -> a
    void dispose() -> b
    void resume() -> c
    com.badlogic.gdx.utils.Array access$000(com.badlogic.gdx.controllers.android.AndroidControllers) -> l
    com.badlogic.gdx.utils.Array access$100(com.badlogic.gdx.controllers.android.AndroidControllers) -> m
    com.badlogic.gdx.utils.Array access$200(com.badlogic.gdx.controllers.android.AndroidControllers) -> n
    com.badlogic.gdx.utils.Array access$300(com.badlogic.gdx.controllers.android.AndroidControllers) -> o
    com.badlogic.gdx.utils.Pool access$400(com.badlogic.gdx.controllers.android.AndroidControllers) -> p
    void addController(int,boolean) -> q
    void gatherControllers(boolean) -> r
    boolean isController(android.view.InputDevice) -> s
    void removeController(int) -> t
    void setupEventQueue() -> u
com.badlogic.gdx.controllers.android.AndroidControllers$1 -> com.badlogic.gdx.controllers.android.AndroidControllers$a:
    com.badlogic.gdx.controllers.android.AndroidControllers this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.controllers.android.AndroidControllerEvent newObject() -> g
com.badlogic.gdx.controllers.android.AndroidControllers$2 -> com.badlogic.gdx.controllers.android.AndroidControllers$b:
    com.badlogic.gdx.controllers.android.AndroidControllers this$0 -> d
com.badlogic.gdx.controllers.android.ControllerLifeCycleListener -> com.badlogic.gdx.controllers.android.c:
    android.hardware.input.InputManager inputManager -> a
    com.badlogic.gdx.controllers.android.AndroidControllers controllers -> b
    void pause() -> a
    void dispose() -> b
    void resume() -> c
com.badlogic.gdx.graphics.Camera -> g.a:
    float viewportHeight -> k
    float viewportWidth -> j
    float far -> i
    float near -> h
    com.badlogic.gdx.math.Vector3 tmpVec -> m
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.collision.Ray ray -> n
    void update() -> a
com.badlogic.gdx.graphics.Color -> g.b:
    com.badlogic.gdx.graphics.Color RED -> E
    com.badlogic.gdx.graphics.Color CORAL -> G
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> f
    com.badlogic.gdx.graphics.Color PINK -> I
    com.badlogic.gdx.graphics.Color DARK_GRAY -> h
    com.badlogic.gdx.graphics.Color PURPLE -> K
    float b -> c
    float r -> a
    com.badlogic.gdx.graphics.Color ORANGE -> A
    com.badlogic.gdx.graphics.Color TAN -> C
    com.badlogic.gdx.graphics.Color CHARTREUSE -> t
    com.badlogic.gdx.graphics.Color FOREST -> v
    com.badlogic.gdx.graphics.Color YELLOW -> x
    com.badlogic.gdx.graphics.Color GOLDENROD -> z
    com.badlogic.gdx.graphics.Color MAROON -> M
    com.badlogic.gdx.graphics.Color BLUE -> l
    com.badlogic.gdx.graphics.Color ROYAL -> n
    com.badlogic.gdx.graphics.Color SKY -> p
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color WHITE -> e
    com.badlogic.gdx.graphics.Color FIREBRICK -> D
    com.badlogic.gdx.graphics.Color GRAY -> g
    float WHITE_FLOAT_BITS -> j
    com.badlogic.gdx.graphics.Color SCARLET -> F
    com.badlogic.gdx.graphics.Color BLACK -> i
    com.badlogic.gdx.graphics.Color SALMON -> H
    com.badlogic.gdx.graphics.Color CLEAR -> k
    com.badlogic.gdx.graphics.Color MAGENTA -> J
    float a -> d
    float g -> b
    com.badlogic.gdx.graphics.Color BROWN -> B
    com.badlogic.gdx.graphics.Color LIME -> u
    com.badlogic.gdx.graphics.Color OLIVE -> w
    com.badlogic.gdx.graphics.Color GOLD -> y
    com.badlogic.gdx.graphics.Color NAVY -> m
    com.badlogic.gdx.graphics.Color VIOLET -> L
    com.badlogic.gdx.graphics.Color SLATE -> o
    com.badlogic.gdx.graphics.Color CYAN -> q
    com.badlogic.gdx.graphics.Color GREEN -> s
    com.badlogic.gdx.graphics.Color clamp() -> a
    int rgba8888(float,float,float,float) -> b
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> c
    float toFloatBits() -> d
    int toIntBits() -> e
com.badlogic.gdx.graphics.Cubemap -> g.c:
    java.util.Map managedCubemaps -> i
    void clearAllCubemaps(com.badlogic.gdx.Application) -> n
    java.lang.String getManagedStatus() -> o
    void invalidateAllCubemaps(com.badlogic.gdx.Application) -> p
    boolean isManaged() -> q
    void load(com.badlogic.gdx.graphics.CubemapData) -> r
    void reload() -> s
com.badlogic.gdx.graphics.CubemapData -> g.d:
    void prepare() -> a
    boolean isPrepared() -> b
    void consumeCubemapData() -> c
com.badlogic.gdx.graphics.GL20 -> g.e:
    void glGenerateMipmap(int) -> a
    void glLinkProgram(int) -> b
    void glTexParameteri(int,int,int) -> c
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> d
    int glGenFramebuffer() -> e
    java.lang.String glGetProgramInfoLog(int) -> f
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> g
    void glGetFloatv(int,java.nio.FloatBuffer) -> i
    void glShaderSource(int,java.lang.String) -> j
    void glAttachShader(int,int) -> k
    java.lang.String glGetShaderInfoLog(int) -> l
    void glCompileShader(int) -> m
    void glBindFramebuffer(int,int) -> n
    int glGenTexture() -> o
    int glCreateProgram() -> p
    int glCreateShader(int) -> q
com.badlogic.gdx.graphics.GL30 -> g.f:
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> h
com.badlogic.gdx.graphics.GLTexture -> g.g:
    float maxAnisotropicFilterLevel -> h
    float anisotropicFilterLevel -> g
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    int glTarget -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    void bind() -> e
    float getMaxAnisotropicFilterLevel() -> f
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> g
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> h
    float unsafeSetAnisotropicFilter(float,boolean) -> i
    void unsafeSetFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> j
    void unsafeSetWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap,boolean) -> k
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> l
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> m
com.badlogic.gdx.graphics.Mesh -> g.h:
    java.util.Map meshes -> a
    void clearAllMeshes(com.badlogic.gdx.Application) -> e
    java.lang.String getManagedStatus() -> f
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> g
com.badlogic.gdx.graphics.OrthographicCamera -> g.i:
    com.badlogic.gdx.math.Vector3 tmp -> p
    float zoom -> o
    void update() -> a
    void update(boolean) -> b
com.badlogic.gdx.graphics.Pixmap -> g.j:
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> c
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> a
    boolean disposed -> e
    com.badlogic.gdx.graphics.Pixmap$Filter filter -> b
    int color -> d
    void dispose() -> b
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> e
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> f
    void fill() -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
    int getGLFormat() -> i
    int getGLInternalFormat() -> j
    int getGLType() -> k
    int getHeight() -> l
    java.nio.ByteBuffer getPixels() -> m
    int getWidth() -> n
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> o
    void setColor(float,float,float,float) -> p
com.badlogic.gdx.graphics.Pixmap$Blending -> g.j$a:
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> f
    com.badlogic.gdx.graphics.Pixmap$Blending None -> d
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> e
com.badlogic.gdx.graphics.Pixmap$Filter -> g.j$b:
    com.badlogic.gdx.graphics.Pixmap$Filter[] $VALUES -> f
    com.badlogic.gdx.graphics.Pixmap$Filter NearestNeighbour -> d
    com.badlogic.gdx.graphics.Pixmap$Filter BiLinear -> e
com.badlogic.gdx.graphics.Pixmap$Format -> g.j$c:
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> k
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> d
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> e
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> g
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> h
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> i
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> j
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.Texture -> g.k:
    java.util.Map managedTextures -> i
    void clearAllTextures(com.badlogic.gdx.Application) -> n
    java.lang.String getManagedStatus() -> o
    void invalidateAllTextures(com.badlogic.gdx.Application) -> p
    boolean isManaged() -> q
    void load(com.badlogic.gdx.graphics.TextureData) -> r
    void reload() -> s
com.badlogic.gdx.graphics.Texture$TextureFilter -> g.k$a:
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> k
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> j
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> i
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> l
    int getGLEnum() -> a
com.badlogic.gdx.graphics.Texture$TextureWrap -> g.k$b:
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> h
    int glEnum -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> g
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureArray -> g.l:
    java.util.Map managedTextureArrays -> i
    void clearAllTextureArrays(com.badlogic.gdx.Application) -> n
    void invalidateAllTextureArrays(com.badlogic.gdx.Application) -> o
    boolean isManaged() -> p
    void load(com.badlogic.gdx.graphics.TextureArrayData) -> q
    void reload() -> r
com.badlogic.gdx.graphics.TextureArrayData -> g.m:
    void prepare() -> a
    boolean isPrepared() -> b
    int getWidth() -> c
    int getHeight() -> d
    int getGLType() -> e
    int getInternalFormat() -> f
    void consumeTextureArrayData() -> g
com.badlogic.gdx.graphics.TextureData -> g.n:
    void prepare() -> a
    boolean isPrepared() -> b
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> d
    boolean useMipMaps() -> e
    boolean disposePixmap() -> f
    void consumeCustomData(int) -> g
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> h
com.badlogic.gdx.graphics.TextureData$TextureDataType -> g.n$a:
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> f
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> d
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long[] nativeData -> f
    long basePtr -> a
    java.nio.ByteBuffer pixelPtr -> e
    int format -> d
    int width -> b
    int height -> c
    void dispose() -> b
    void clear(int) -> e
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> f
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> g
    int getFormat() -> h
    java.lang.String getFormatString(int) -> i
    int getGLFormat() -> j
    int getGLInternalFormat() -> k
    int getGLType() -> l
    int getHeight() -> m
    java.nio.ByteBuffer getPixels() -> n
    int getWidth() -> o
    void setBlend(int) -> p
    int toGlFormat(int) -> q
    int toGlType(int) -> r
com.badlogic.gdx.graphics.glutils.GLFrameBuffer -> h.a:
    java.util.Map buffers -> c
    com.badlogic.gdx.utils.Array textureAttachments -> a
    boolean defaultFramebufferHandleInitialized -> e
    int defaultFramebufferHandle -> d
    int framebufferHandle -> b
    void build() -> e
    void checkValidBuilder() -> f
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> g
    java.lang.String getManagedStatus() -> h
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> i
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> j
com.badlogic.gdx.graphics.glutils.GLVersion -> h.b:
    java.lang.String TAG -> g
    int minorVersion -> b
    int releaseVersion -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type type -> f
    java.lang.String rendererString -> e
    int majorVersion -> a
    java.lang.String vendorString -> d
    void extractVersion(java.lang.String,java.lang.String) -> a
    int getMajorVersion() -> b
    int parseInt(java.lang.String,int) -> c
com.badlogic.gdx.graphics.glutils.GLVersion$Type -> h.b$a:
    com.badlogic.gdx.graphics.glutils.GLVersion$Type GLES -> e
    com.badlogic.gdx.graphics.glutils.GLVersion$Type OpenGL -> d
    com.badlogic.gdx.graphics.glutils.GLVersion$Type[] $VALUES -> h
    com.badlogic.gdx.graphics.glutils.GLVersion$Type NONE -> g
    com.badlogic.gdx.graphics.glutils.GLVersion$Type WebGL -> f
com.badlogic.gdx.graphics.glutils.HdpiMode -> h.c:
    com.badlogic.gdx.graphics.glutils.HdpiMode[] $VALUES -> f
    com.badlogic.gdx.graphics.glutils.HdpiMode Pixels -> e
    com.badlogic.gdx.graphics.glutils.HdpiMode Logical -> d
com.badlogic.gdx.graphics.glutils.HdpiUtils -> h.d:
    com.badlogic.gdx.graphics.glutils.HdpiMode mode -> a
    void glViewport(int,int,int,int) -> a
    int toBackBufferX(int) -> b
    int toBackBufferY(int) -> c
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> h.e:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> d
com.badlogic.gdx.graphics.glutils.ShaderProgram -> h.f:
    java.lang.String fragmentShaderSource -> g
    com.badlogic.gdx.utils.ObjectMap shaders -> i
    java.lang.String vertexShaderSource -> f
    java.nio.IntBuffer intbuf -> j
    java.lang.String log -> a
    int vertexShaderHandle -> d
    int fragmentShaderHandle -> e
    boolean invalidated -> h
    boolean isCompiled -> b
    int program -> c
    void checkManaged() -> e
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> f
    void compileShaders(java.lang.String,java.lang.String) -> g
    int createProgram() -> h
    java.lang.String getManagedStatus() -> i
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> j
    int linkProgram(int) -> k
    int loadShader(int,java.lang.String) -> l
com.badlogic.gdx.math.Frustum -> i.a:
    com.badlogic.gdx.math.Vector3[] planePoints -> b
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> d
    float[] clipSpacePlanePointsArray -> e
    float[] planePointsArray -> c
    com.badlogic.gdx.math.Plane[] planes -> a
    com.badlogic.gdx.math.Vector3 tmpV -> f
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.MathUtils -> i.b:
    java.util.Random random -> a
    boolean isEqual(float,float,float) -> a
    int nextPowerOfTwo(int) -> b
    int roundPositive(float) -> c
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    com.badlogic.gdx.math.Quaternion quat2 -> f
    com.badlogic.gdx.math.Quaternion quat -> e
    com.badlogic.gdx.math.Vector3 tmpUp -> n
    com.badlogic.gdx.math.Matrix4 tmpMat -> k
    com.badlogic.gdx.math.Vector3 right -> l
    com.badlogic.gdx.math.Vector3 tmpForward -> m
    com.badlogic.gdx.math.Vector3 tmpVec -> j
    float[] val -> d
    com.badlogic.gdx.math.Vector3 l_vex -> h
    com.badlogic.gdx.math.Vector3 l_vey -> i
    com.badlogic.gdx.math.Vector3 l_vez -> g
    float det(float[]) -> a
    com.badlogic.gdx.math.Matrix4 idt() -> b
    boolean inv(float[]) -> c
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> d
    void mul(float[],float[]) -> e
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> f
    com.badlogic.gdx.math.Matrix4 set(float[]) -> g
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> h
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> i
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> j
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> k
com.badlogic.gdx.math.Plane -> i.c:
    com.badlogic.gdx.math.Vector3 normal -> d
    float d -> e
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
com.badlogic.gdx.math.Quaternion -> i.d:
    com.badlogic.gdx.math.Quaternion tmp2 -> i
    com.badlogic.gdx.math.Quaternion tmp1 -> h
    float w -> g
    float z -> f
    float y -> e
    float x -> d
    com.badlogic.gdx.math.Quaternion idt() -> a
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> b
com.badlogic.gdx.math.RandomXS128 -> i.e:
    long seed1 -> e
    long seed0 -> d
    long murmurHash3(long) -> a
    long nextLong(long) -> b
    void setState(long,long) -> c
com.badlogic.gdx.math.Vector3 -> i.f:
    float z -> f
    float y -> e
    float x -> d
    com.badlogic.gdx.math.Matrix4 tmpMat -> k
    com.badlogic.gdx.math.Vector3 Zero -> j
    com.badlogic.gdx.math.Vector3 Y -> h
    com.badlogic.gdx.math.Vector3 Z -> i
    com.badlogic.gdx.math.Vector3 X -> g
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> d
    float dot(com.badlogic.gdx.math.Vector3) -> e
    float len2() -> f
    com.badlogic.gdx.math.Vector3 nor() -> g
    com.badlogic.gdx.math.Vector3 scl(float) -> h
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> i
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> j
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> k
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> l
com.badlogic.gdx.math.collision.Ray -> j.a:
    com.badlogic.gdx.math.Vector3 origin -> d
    com.badlogic.gdx.math.Vector3 direction -> e
    com.badlogic.gdx.math.Vector3 tmp -> f
com.badlogic.gdx.net.NetJavaImpl -> k.a:
    java.util.concurrent.ThreadPoolExecutor executorService -> a
    com.badlogic.gdx.utils.ObjectMap tasks -> d
    com.badlogic.gdx.utils.ObjectMap listeners -> c
    com.badlogic.gdx.utils.ObjectMap connections -> b
com.badlogic.gdx.net.NetJavaImpl$1 -> k.a$a:
    java.util.concurrent.atomic.AtomicInteger threadID -> a
    com.badlogic.gdx.net.NetJavaImpl this$0 -> b
com.badlogic.gdx.utils.Array -> l.a:
    java.lang.Object[] items -> d
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> g
    boolean ordered -> f
    int size -> e
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> b
    void addAll(java.lang.Object[],int,int) -> c
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> d
    java.lang.Object removeIndex(int) -> e
    boolean removeValue(java.lang.Object,boolean) -> f
    java.lang.Object[] resize(int) -> g
com.badlogic.gdx.utils.Array$ArrayIterable -> l.a$a:
    boolean allowRemove -> e
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> f
    com.badlogic.gdx.utils.Array array -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> g
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.Array$ArrayIterator -> l.a$b:
    boolean allowRemove -> e
    int index -> f
    com.badlogic.gdx.utils.Array array -> d
    boolean valid -> g
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    java.nio.FloatBuffer newFloatBuffer(int) -> a
    java.nio.IntBuffer newIntBuffer(int) -> b
com.badlogic.gdx.utils.Collections -> l.b:
    boolean allocateIterators -> a
com.badlogic.gdx.utils.Disposable -> l.c:
    void dispose() -> b
com.badlogic.gdx.utils.GdxNativesLoader -> l.d:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> l.e:
com.badlogic.gdx.utils.IntIntMap -> l.f:
    int[] valueTable -> f
    int mask -> l
    float loadFactor -> i
    int threshold -> j
    int shift -> k
    int[] keyTable -> e
    int zeroValue -> g
    int size -> d
    boolean hasZeroValue -> h
    com.badlogic.gdx.utils.IntIntMap$Entries entries2 -> n
    com.badlogic.gdx.utils.IntIntMap$Entries entries1 -> m
    boolean containsKey(int) -> a
    com.badlogic.gdx.utils.IntIntMap$Entries entries() -> b
    int get(int,int) -> c
    int locateKey(int) -> d
    int place(int) -> e
    void put(int,int) -> f
    void putResize(int,int) -> g
    int remove(int,int) -> h
    void resize(int) -> i
com.badlogic.gdx.utils.IntIntMap$Entries -> l.f$a:
    com.badlogic.gdx.utils.IntIntMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.IntIntMap$Entry next() -> c
com.badlogic.gdx.utils.IntIntMap$Entry -> l.f$b:
    int value -> b
    int key -> a
com.badlogic.gdx.utils.IntIntMap$MapIterator -> l.f$c:
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    com.badlogic.gdx.utils.IntIntMap map -> e
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntMap -> l.g:
    com.badlogic.gdx.utils.IntMap$Entries entries2 -> n
    int mask -> l
    float loadFactor -> i
    int threshold -> j
    java.lang.Object zeroValue -> g
    int shift -> k
    int[] keyTable -> e
    com.badlogic.gdx.utils.IntMap$Entries entries1 -> m
    int size -> d
    boolean hasZeroValue -> h
    java.lang.Object[] valueTable -> f
    void ensureCapacity(int) -> a
    com.badlogic.gdx.utils.IntMap$Entries entries() -> b
    java.lang.Object get(int,java.lang.Object) -> c
    int locateKey(int) -> d
    int place(int) -> e
    java.lang.Object put(int,java.lang.Object) -> f
    void putAll(com.badlogic.gdx.utils.IntMap) -> g
    void putResize(int,java.lang.Object) -> h
    void resize(int) -> i
com.badlogic.gdx.utils.IntMap$Entries -> l.g$a:
    com.badlogic.gdx.utils.IntMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.IntMap$Entry next() -> c
com.badlogic.gdx.utils.IntMap$Entry -> l.g$b:
    java.lang.Object value -> b
    int key -> a
com.badlogic.gdx.utils.IntMap$MapIterator -> l.g$c:
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    com.badlogic.gdx.utils.IntMap map -> e
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntSet -> l.h:
    int[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    boolean hasZeroValue -> c
    int size -> a
    boolean add(int) -> a
    void addResize(int) -> b
    boolean contains(int) -> c
    int locateKey(int) -> d
    int place(int) -> e
    boolean remove(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.NumberUtils -> l.i:
    int floatToIntBits(float) -> a
    int floatToRawIntBits(float) -> b
    float intToFloatColor(int) -> c
com.badlogic.gdx.utils.ObjectMap -> l.j:
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> n
    java.lang.Object[] keyTable -> e
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> m
    int mask -> j
    float loadFactor -> g
    int threshold -> h
    int shift -> i
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> k
    int size -> d
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> l
    java.lang.Object dummy -> o
    java.lang.Object[] valueTable -> f
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> a
    java.lang.Object get(java.lang.Object) -> b
    java.lang.Object get(java.lang.Object,java.lang.Object) -> c
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> d
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> e
    int locateKey(java.lang.Object) -> f
    int place(java.lang.Object) -> g
    java.lang.Object remove(java.lang.Object) -> h
    java.lang.String toString(java.lang.String,boolean) -> i
com.badlogic.gdx.utils.ObjectMap$Entries -> l.j$a:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> i
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectMap$Entry -> l.j$b:
    java.lang.Object value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectMap$Keys -> l.j$c:
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Keys iterator() -> c
com.badlogic.gdx.utils.ObjectMap$MapIterator -> l.j$d:
    int nextIndex -> f
    int currentIndex -> g
    boolean valid -> h
    com.badlogic.gdx.utils.ObjectMap map -> e
    boolean hasNext -> d
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectSet -> l.k:
    int tableSize(int,float) -> a
com.badlogic.gdx.utils.Pool -> l.l:
    com.badlogic.gdx.utils.Array freeObjects -> c
    int peak -> b
    int max -> a
    void discard(java.lang.Object) -> a
    void free(java.lang.Object) -> b
    void freeAll(com.badlogic.gdx.utils.Array) -> c
    java.lang.Object newObject() -> d
    java.lang.Object obtain() -> e
    void reset(java.lang.Object) -> f
com.badlogic.gdx.utils.Pool$Poolable -> l.l$a:
com.badlogic.gdx.utils.ScreenUtils -> l.m:
    void clear(float,float,float,float) -> a
    void clear(float,float,float,float,boolean) -> b
com.badlogic.gdx.utils.SharedLibraryLoadRuntimeException -> l.n:
com.badlogic.gdx.utils.SharedLibraryLoader -> l.o:
    java.util.Random random -> j
    boolean isIos -> e
    boolean isAndroid -> f
    java.lang.String nativesJar -> a
    boolean isARM -> g
    boolean is64Bit -> h
    boolean isWindows -> b
    boolean isLinux -> c
    boolean isMac -> d
    java.util.HashSet loadedLibraries -> i
    void closeQuietly(java.io.Closeable) -> a
    java.lang.String crc(java.io.InputStream) -> b
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> c
    boolean isLoaded(java.lang.String) -> d
    void load(java.lang.String) -> e
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> f
    void loadFile(java.lang.String) -> g
    java.lang.String mapLibraryName(java.lang.String) -> h
    java.io.InputStream readFile(java.lang.String) -> i
    void setLoaded(java.lang.String) -> j
com.badlogic.gdx.utils.SnapshotArray -> l.p:
    int snapshots -> j
    java.lang.Object[] snapshot -> h
    java.lang.Object[] recycled -> i
    java.lang.Object removeIndex(int) -> e
    boolean removeValue(java.lang.Object,boolean) -> f
    java.lang.Object[] begin() -> h
    void end() -> i
    void modified() -> j
com.badlogic.gdx.utils.StringBuilder -> l.q:
    char[] chars -> d
    char[] digits -> f
    int length -> e
    com.badlogic.gdx.utils.StringBuilder append(char) -> a
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> b
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> c
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> d
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> e
    void append0(char) -> f
    void append0(java.lang.CharSequence,int,int) -> g
    void append0(java.lang.String) -> h
    void append0(char[],int,int) -> i
    void appendNull() -> j
    void enlargeBuffer(int) -> k
    java.lang.String substring(int,int) -> l
com.badlogic.gdx.utils.reflect.ArrayReflection -> m.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
com.badlogic.gdx.utils.reflect.ClassReflection -> m.b:
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> a
com.badlogic.gdx.utils.reflect.Constructor -> m.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    java.lang.Object newInstance(java.lang.Object[]) -> b
com.badlogic.gdx.utils.reflect.ReflectionException -> m.d:
com.badlogic.gdx.utils.viewport.ScreenViewport -> n.a:
    float unitsPerPixel -> i
com.badlogic.gdx.utils.viewport.Viewport -> n.b:
    com.badlogic.gdx.graphics.Camera camera -> a
    int screenWidth -> f
    float worldHeight -> c
    int screenHeight -> g
    float worldWidth -> b
    int screenX -> d
    int screenY -> e
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply() -> a
    void apply(boolean) -> b
    void setCamera(com.badlogic.gdx.graphics.Camera) -> c
com.hasanchik.game.MyGame -> o.a:
    com.badlogic.gdx.utils.viewport.Viewport viewport -> c
    java.util.EnumMap screenCache -> b
    java.lang.String TAG -> d
    void create() -> e
    void setScreen(com.hasanchik.game.screens.ScreenType) -> h
com.hasanchik.game.screens.AbstractScreen -> p.a:
    com.hasanchik.game.MyGame context -> b
    com.badlogic.gdx.utils.viewport.Viewport viewport -> a
    void resize(int,int) -> d
    void render(float) -> e
com.hasanchik.game.screens.GameScreen -> p.b:
    void pause() -> a
    void show() -> b
    void resume() -> c
    void render(float) -> e
    void hide() -> f
com.hasanchik.game.screens.LoadingScreen -> p.c:
    void pause() -> a
    void show() -> b
    void resume() -> c
    void render(float) -> e
    void hide() -> f
com.hasanchik.game.screens.MainMenuScreen -> p.d:
    void pause() -> a
    void show() -> b
    void resume() -> c
    void hide() -> f
com.hasanchik.game.screens.ScreenType -> p.e:
    com.hasanchik.game.screens.ScreenType[] $VALUES -> h
    com.hasanchik.game.screens.ScreenType LOADING -> f
    com.hasanchik.game.screens.ScreenType GAME -> e
    java.lang.Class screenClass -> d
    com.hasanchik.game.screens.ScreenType MAINMENU -> g
    com.hasanchik.game.screens.ScreenType[] $values() -> a
    java.lang.Class getScreenClass() -> b
kotlin.ExceptionsKt -> q.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ExceptionsKt__ExceptionsKt -> q.b:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
kotlin.KotlinNothingValueException -> q.c:
kotlin.Pair -> q.d:
    java.lang.Object first -> d
    java.lang.Object second -> e
    java.lang.Object component1() -> a
    java.lang.Object component2() -> b
    java.lang.Object getFirst() -> c
    java.lang.Object getSecond() -> d
kotlin.Result -> q.e:
    kotlin.Result$Companion Companion -> d
    java.lang.Object constructor-impl(java.lang.Object) -> a
    java.lang.Throwable exceptionOrNull-impl(java.lang.Object) -> b
    boolean isFailure-impl(java.lang.Object) -> c
    boolean isSuccess-impl(java.lang.Object) -> d
kotlin.Result$Companion -> q.e$a:
kotlin.Result$Failure -> q.e$b:
    java.lang.Throwable exception -> d
kotlin.ResultKt -> q.f:
    java.lang.Object createFailure(java.lang.Throwable) -> a
kotlin.TuplesKt -> q.g:
    kotlin.Pair to(java.lang.Object,java.lang.Object) -> a
kotlin.UninitializedPropertyAccessException -> q.h:
kotlin.Unit -> q.i:
    kotlin.Unit INSTANCE -> a
kotlin.collections.ArraysKt -> r.a:
    java.lang.Object[] copyInto$default(java.lang.Object[],java.lang.Object[],int,int,int,int,java.lang.Object) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    char single(char[]) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object singleOrNull(java.lang.Object[]) -> e
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.ArraysKt__ArraysJVMKt -> r.b:
kotlin.collections.ArraysKt__ArraysKt -> r.c:
kotlin.collections.ArraysKt___ArraysJvmKt -> r.d:
    java.util.List asList(java.lang.Object[]) -> a
    java.lang.Object[] copyInto(java.lang.Object[],java.lang.Object[],int,int,int) -> b
    java.lang.Object[] copyInto$default(java.lang.Object[],java.lang.Object[],int,int,int,int,java.lang.Object) -> c
kotlin.collections.ArraysKt___ArraysKt -> r.e:
    char single(char[]) -> d
    java.lang.Object singleOrNull(java.lang.Object[]) -> e
kotlin.collections.ArraysUtilJVM -> r.f:
    java.util.List asList(java.lang.Object[]) -> a
kotlin.collections.CollectionsKt -> r.g:
    java.util.List listOf(java.lang.Object[]) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List optimizeReadOnlyList(java.util.List) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    void throwIndexOverflow() -> e
      # {"id":"com.android.tools.r8.synthesized"}
    int collectionSizeOrDefault(java.lang.Iterable,int) -> f
      # {"id":"com.android.tools.r8.synthesized"}
    boolean addAll(java.util.Collection,java.lang.Iterable) -> g
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List toList(java.lang.Iterable) -> i
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Set toSet(java.lang.Iterable) -> l
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.CollectionsKt__CollectionsJVMKt -> r.h:
    java.util.List listOf(java.lang.Object) -> a
kotlin.collections.CollectionsKt__CollectionsKt -> r.i:
    java.util.List emptyList() -> b
    java.util.List listOf(java.lang.Object[]) -> c
    java.util.List optimizeReadOnlyList(java.util.List) -> d
    void throwIndexOverflow() -> e
kotlin.collections.CollectionsKt__IterablesKt -> r.j:
    int collectionSizeOrDefault(java.lang.Iterable,int) -> f
kotlin.collections.CollectionsKt__IteratorsJVMKt -> r.k:
kotlin.collections.CollectionsKt__IteratorsKt -> r.l:
kotlin.collections.CollectionsKt__MutableCollectionsJVMKt -> r.m:
kotlin.collections.CollectionsKt__MutableCollectionsKt -> r.n:
    boolean addAll(java.util.Collection,java.lang.Iterable) -> g
kotlin.collections.CollectionsKt__ReversedViewsKt -> r.o:
kotlin.collections.CollectionsKt___CollectionsJvmKt -> r.p:
kotlin.collections.CollectionsKt___CollectionsKt -> r.q:
    java.util.Collection toCollection(java.lang.Iterable,java.util.Collection) -> h
    java.util.List toList(java.lang.Iterable) -> i
    java.util.List toMutableList(java.lang.Iterable) -> j
    java.util.List toMutableList(java.util.Collection) -> k
    java.util.Set toSet(java.lang.Iterable) -> l
kotlin.collections.EmptyIterator -> r.r:
    kotlin.collections.EmptyIterator INSTANCE -> d
    java.lang.Void next() -> a
    java.lang.Void previous() -> b
kotlin.collections.EmptyList -> r.s:
    kotlin.collections.EmptyList INSTANCE -> d
    boolean contains(java.lang.Void) -> a
    java.lang.Void get(int) -> b
    int getSize() -> c
    int indexOf(java.lang.Void) -> d
    int lastIndexOf(java.lang.Void) -> e
kotlin.collections.EmptyMap -> r.t:
    kotlin.collections.EmptyMap INSTANCE -> d
    boolean containsValue(java.lang.Void) -> a
    java.lang.Void get(java.lang.Object) -> b
    java.util.Set getEntries() -> c
    java.util.Set getKeys() -> d
    int getSize() -> e
    java.util.Collection getValues() -> f
    java.lang.Void remove(java.lang.Object) -> g
kotlin.collections.EmptySet -> r.u:
    kotlin.collections.EmptySet INSTANCE -> d
    boolean contains(java.lang.Void) -> a
    int getSize() -> b
kotlin.collections.IntIterator -> r.v:
kotlin.collections.MapsKt -> r.w:
    int mapCapacity(int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.Map toMap(java.lang.Iterable) -> g
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.collections.MapsKt__MapWithDefaultKt -> r.x:
kotlin.collections.MapsKt__MapsJVMKt -> r.y:
    int mapCapacity(int) -> a
    java.util.Map mapOf(kotlin.Pair) -> b
    java.util.Map toSingletonMap(java.util.Map) -> c
kotlin.collections.MapsKt__MapsKt -> r.z:
    java.util.Map emptyMap() -> d
    java.util.Map optimizeReadOnlyMap(java.util.Map) -> e
    void putAll(java.util.Map,java.lang.Iterable) -> f
    java.util.Map toMap(java.lang.Iterable) -> g
    java.util.Map toMap(java.lang.Iterable,java.util.Map) -> h
kotlin.collections.MapsKt___MapsKt -> r.a0:
kotlin.collections.SetsKt__SetsJVMKt -> r.b0:
    java.util.Set setOf(java.lang.Object) -> a
kotlin.collections.SetsKt__SetsKt -> r.c0:
    java.util.Set emptySet() -> b
    java.util.Set optimizeReadOnlySet(java.util.Set) -> c
kotlin.coroutines.AbstractCoroutineContextElement -> s.a:
kotlin.coroutines.AbstractCoroutineContextKey -> s.b:
    kotlin.coroutines.CoroutineContext$Key topmostKey -> e
    kotlin.jvm.functions.Function1 safeCast -> d
    boolean isSubKey$kotlin_stdlib(kotlin.coroutines.CoroutineContext$Key) -> a
    kotlin.coroutines.CoroutineContext$Element tryCast$kotlin_stdlib(kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.CombinedContext -> s.c:
    kotlin.coroutines.CoroutineContext$Element element -> e
    kotlin.coroutines.CoroutineContext left -> d
    boolean contains(kotlin.coroutines.CoroutineContext$Element) -> c
    boolean containsAll(kotlin.coroutines.CombinedContext) -> g
    int size() -> h
kotlin.coroutines.CombinedContext$toString$1 -> s.c$a:
    kotlin.coroutines.CombinedContext$toString$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    java.lang.String invoke(java.lang.String,kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.Continuation -> s.d:
    kotlin.coroutines.CoroutineContext getContext() -> c
    void resumeWith(java.lang.Object) -> h
kotlin.coroutines.ContinuationInterceptor -> s.e:
    kotlin.coroutines.ContinuationInterceptor$Key Key -> c
    kotlin.coroutines.Continuation interceptContinuation(kotlin.coroutines.Continuation) -> f
    void releaseInterceptedContinuation(kotlin.coroutines.Continuation) -> k
kotlin.coroutines.ContinuationInterceptor$DefaultImpls -> s.e$a:
    kotlin.coroutines.CoroutineContext$Element get(kotlin.coroutines.ContinuationInterceptor,kotlin.coroutines.CoroutineContext$Key) -> a
    kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.ContinuationInterceptor,kotlin.coroutines.CoroutineContext$Key) -> b
kotlin.coroutines.ContinuationInterceptor$Key -> s.e$b:
    kotlin.coroutines.ContinuationInterceptor$Key $$INSTANCE -> d
kotlin.coroutines.CoroutineContext -> s.f:
kotlin.coroutines.CoroutineContext$DefaultImpls -> s.f$a:
    kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext) -> a
kotlin.coroutines.CoroutineContext$Element -> s.f$b:
kotlin.coroutines.CoroutineContext$Element$DefaultImpls -> s.f$b$a:
    java.lang.Object fold(kotlin.coroutines.CoroutineContext$Element,java.lang.Object,kotlin.jvm.functions.Function2) -> a
    kotlin.coroutines.CoroutineContext$Element get(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext$Key) -> b
    kotlin.coroutines.CoroutineContext minusKey(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext$Key) -> c
    kotlin.coroutines.CoroutineContext plus(kotlin.coroutines.CoroutineContext$Element,kotlin.coroutines.CoroutineContext) -> d
kotlin.coroutines.CoroutineContext$Key -> s.f$c:
kotlin.coroutines.CoroutineContext$plus$1 -> s.f$a$a:
    kotlin.coroutines.CoroutineContext$plus$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    kotlin.coroutines.CoroutineContext invoke(kotlin.coroutines.CoroutineContext,kotlin.coroutines.CoroutineContext$Element) -> b
kotlin.coroutines.EmptyCoroutineContext -> s.g:
    kotlin.coroutines.EmptyCoroutineContext INSTANCE -> d
kotlin.coroutines.intrinsics.CoroutineSingletons -> t.a:
    kotlin.coroutines.intrinsics.CoroutineSingletons UNDECIDED -> e
    kotlin.coroutines.intrinsics.CoroutineSingletons RESUMED -> f
    kotlin.coroutines.intrinsics.CoroutineSingletons COROUTINE_SUSPENDED -> d
    kotlin.coroutines.intrinsics.CoroutineSingletons[] $VALUES -> g
    kotlin.coroutines.intrinsics.CoroutineSingletons[] $values() -> a
kotlin.coroutines.intrinsics.IntrinsicsKt -> t.b:
    kotlin.coroutines.Continuation intercepted(kotlin.coroutines.Continuation) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.Object getCOROUTINE_SUSPENDED() -> b
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt -> t.c:
    kotlin.coroutines.Continuation intercepted(kotlin.coroutines.Continuation) -> a
kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsKt -> t.d:
    java.lang.Object getCOROUTINE_SUSPENDED() -> b
kotlin.coroutines.jvm.internal.BaseContinuationImpl -> u.a:
    kotlin.coroutines.Continuation completion -> d
    java.lang.StackTraceElement getStackTraceElement() -> a
    java.lang.Object invokeSuspend(java.lang.Object) -> b
    void releaseIntercepted() -> d
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> g
    void resumeWith(java.lang.Object) -> h
kotlin.coroutines.jvm.internal.CompletedContinuation -> u.b:
    kotlin.coroutines.jvm.internal.CompletedContinuation INSTANCE -> d
    kotlin.coroutines.CoroutineContext getContext() -> c
    void resumeWith(java.lang.Object) -> h
kotlin.coroutines.jvm.internal.ContinuationImpl -> u.c:
    kotlin.coroutines.CoroutineContext _context -> e
    kotlin.coroutines.Continuation intercepted -> f
    kotlin.coroutines.CoroutineContext getContext() -> c
    void releaseIntercepted() -> d
    kotlin.coroutines.Continuation intercepted() -> e
kotlin.coroutines.jvm.internal.CoroutineStackFrame -> u.d:
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> g
kotlin.coroutines.jvm.internal.DebugMetadata -> u.e:
kotlin.coroutines.jvm.internal.DebugMetadataKt -> u.f:
    void checkDebugMetadataVersion(int,int) -> a
    kotlin.coroutines.jvm.internal.DebugMetadata getDebugMetadataAnnotation(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> b
    int getLabel(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> c
    java.lang.StackTraceElement getStackTraceElement(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> d
kotlin.coroutines.jvm.internal.DebugProbesKt -> u.g:
    void probeCoroutineResumed(kotlin.coroutines.Continuation) -> a
kotlin.coroutines.jvm.internal.ModuleNameRetriever -> u.h:
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache notOnJava9 -> b
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache cache -> c
    kotlin.coroutines.jvm.internal.ModuleNameRetriever INSTANCE -> a
    kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache buildCache(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> a
    java.lang.String getModuleName(kotlin.coroutines.jvm.internal.BaseContinuationImpl) -> b
kotlin.coroutines.jvm.internal.ModuleNameRetriever$Cache -> u.h$a:
    java.lang.reflect.Method nameMethod -> c
    java.lang.reflect.Method getModuleMethod -> a
    java.lang.reflect.Method getDescriptorMethod -> b
kotlin.internal.PlatformImplementations -> v.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
    kotlin.random.Random defaultPlatformRandom() -> b
kotlin.internal.PlatformImplementations$ReflectThrowable -> v.a$a:
    kotlin.internal.PlatformImplementations$ReflectThrowable INSTANCE -> a
    java.lang.reflect.Method getSuppressed -> c
    java.lang.reflect.Method addSuppressed -> b
kotlin.internal.PlatformImplementationsKt -> v.b:
    kotlin.internal.PlatformImplementations IMPLEMENTATIONS -> a
    int getJavaVersion() -> a
kotlin.internal.ProgressionUtilKt -> v.c:
    int differenceModulo(int,int,int) -> a
    int getProgressionLastElement(int,int,int) -> b
    int mod(int,int) -> c
kotlin.internal.jdk7.JDK7PlatformImplementations -> w.a:
    void addSuppressed(java.lang.Throwable,java.lang.Throwable) -> a
kotlin.internal.jdk8.JDK8PlatformImplementations -> x.a:
    kotlin.random.Random defaultPlatformRandom() -> b
kotlin.io.CloseableKt -> y.a:
    void closeFinally(java.io.Closeable,java.lang.Throwable) -> a
kotlin.jvm.JvmClassMappingKt -> z.a:
    java.lang.Class getJavaObjectType(kotlin.reflect.KClass) -> a
kotlin.jvm.functions.Function0 -> a0.a:
kotlin.jvm.functions.Function1 -> a0.l:
    java.lang.Object invoke(java.lang.Object) -> e
kotlin.jvm.functions.Function10 -> a0.b:
kotlin.jvm.functions.Function11 -> a0.c:
kotlin.jvm.functions.Function12 -> a0.d:
kotlin.jvm.functions.Function13 -> a0.e:
kotlin.jvm.functions.Function14 -> a0.f:
kotlin.jvm.functions.Function15 -> a0.g:
kotlin.jvm.functions.Function16 -> a0.h:
kotlin.jvm.functions.Function17 -> a0.i:
kotlin.jvm.functions.Function18 -> a0.j:
kotlin.jvm.functions.Function19 -> a0.k:
kotlin.jvm.functions.Function2 -> a0.p:
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
kotlin.jvm.functions.Function20 -> a0.m:
kotlin.jvm.functions.Function21 -> a0.n:
kotlin.jvm.functions.Function22 -> a0.o:
kotlin.jvm.functions.Function3 -> a0.q:
kotlin.jvm.functions.Function4 -> a0.r:
kotlin.jvm.functions.Function5 -> a0.s:
kotlin.jvm.functions.Function6 -> a0.t:
kotlin.jvm.functions.Function7 -> a0.u:
kotlin.jvm.functions.Function8 -> a0.v:
kotlin.jvm.functions.Function9 -> a0.w:
kotlin.jvm.internal.CallableReference -> b0.a:
    java.lang.Class owner -> f
    java.lang.String name -> g
    java.lang.Object NO_RECEIVER -> j
    java.lang.String signature -> h
    boolean isTopLevel -> i
    java.lang.Object receiver -> e
    kotlin.reflect.KCallable reflected -> d
    kotlin.reflect.KCallable compute() -> a
    kotlin.reflect.KCallable computeReflected() -> b
    java.lang.Object getBoundReceiver() -> c
    java.lang.String getName() -> d
    kotlin.reflect.KDeclarationContainer getOwner() -> e
    java.lang.String getSignature() -> f
kotlin.jvm.internal.CallableReference$NoReceiver -> b0.a$a:
    kotlin.jvm.internal.CallableReference$NoReceiver INSTANCE -> d
    kotlin.jvm.internal.CallableReference$NoReceiver access$000() -> a
kotlin.jvm.internal.ClassBasedDeclarationContainer -> b0.b:
    java.lang.Class getJClass() -> a
kotlin.jvm.internal.ClassReference -> b0.c:
    java.util.Map FUNCTION_CLASSES -> c
    kotlin.jvm.internal.ClassReference$Companion Companion -> b
    java.util.HashMap classFqNames -> f
    java.lang.Class jClass -> a
    java.util.HashMap primitiveWrapperFqNames -> e
    java.util.HashMap primitiveFqNames -> d
    java.util.Map simpleNames -> g
    java.lang.Class getJClass() -> a
kotlin.jvm.internal.ClassReference$Companion -> b0.c$a:
kotlin.jvm.internal.CollectionToArray -> b0.d:
    java.lang.Object[] EMPTY -> a
    java.lang.Object[] toArray(java.util.Collection) -> a
    java.lang.Object[] toArray(java.util.Collection,java.lang.Object[]) -> b
kotlin.jvm.internal.DefaultConstructorMarker -> b0.e:
kotlin.jvm.internal.FunctionBase -> b0.f:
kotlin.jvm.internal.Intrinsics -> b0.g:
    boolean areEqual(java.lang.Object,java.lang.Object) -> a
    void checkNotNull(java.lang.Object) -> b
    void checkNotNullExpressionValue(java.lang.Object,java.lang.String) -> c
    void checkNotNullParameter(java.lang.Object,java.lang.String) -> d
    int compare(int,int) -> e
    java.lang.String createParameterIsNullExceptionMessage(java.lang.String) -> f
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable) -> g
    java.lang.Throwable sanitizeStackTrace(java.lang.Throwable,java.lang.String) -> h
    java.lang.String stringPlus(java.lang.String,java.lang.Object) -> i
    void throwJavaNpe() -> j
    void throwParameterIsNullNPE(java.lang.String) -> k
    void throwUninitializedProperty(java.lang.String) -> l
    void throwUninitializedPropertyAccessException(java.lang.String) -> m
kotlin.jvm.internal.Lambda -> b0.h:
    int arity -> d
kotlin.jvm.internal.PackageReference -> b0.i:
    java.lang.Class jClass -> a
    java.lang.String moduleName -> b
    java.lang.Class getJClass() -> a
kotlin.jvm.internal.PropertyReference -> b0.l:
kotlin.jvm.internal.PropertyReference0 -> b0.j:
    kotlin.reflect.KCallable computeReflected() -> b
kotlin.jvm.internal.PropertyReference0Impl -> b0.k:
kotlin.jvm.internal.Reflection -> b0.m:
    kotlin.reflect.KClass[] EMPTY_K_CLASS_ARRAY -> b
    kotlin.jvm.internal.ReflectionFactory factory -> a
    kotlin.reflect.KClass getOrCreateKotlinClass(java.lang.Class) -> a
    kotlin.reflect.KDeclarationContainer getOrCreateKotlinPackage(java.lang.Class) -> b
    kotlin.reflect.KProperty0 property0(kotlin.jvm.internal.PropertyReference0) -> c
    java.lang.String renderLambdaToString(kotlin.jvm.internal.Lambda) -> d
kotlin.jvm.internal.ReflectionFactory -> b0.n:
    kotlin.reflect.KClass getOrCreateKotlinClass(java.lang.Class) -> a
    kotlin.reflect.KDeclarationContainer getOrCreateKotlinPackage(java.lang.Class,java.lang.String) -> b
    kotlin.reflect.KProperty0 property0(kotlin.jvm.internal.PropertyReference0) -> c
    java.lang.String renderLambdaToString(kotlin.jvm.internal.FunctionBase) -> d
    java.lang.String renderLambdaToString(kotlin.jvm.internal.Lambda) -> e
kotlin.random.AbstractPlatformRandom -> c0.a:
    int nextInt() -> b
    java.util.Random getImpl() -> c
kotlin.random.FallbackThreadLocalRandom -> c0.b:
    kotlin.random.FallbackThreadLocalRandom$implStorage$1 implStorage -> f
    java.util.Random getImpl() -> c
kotlin.random.FallbackThreadLocalRandom$implStorage$1 -> c0.b$a:
    java.util.Random initialValue() -> a
kotlin.random.Random -> c0.c:
    kotlin.random.Random$Default Default -> d
    kotlin.random.Random defaultRandom -> e
    kotlin.random.Random access$getDefaultRandom$cp() -> a
    int nextInt() -> b
kotlin.random.Random$Default -> c0.c$a:
    int nextInt() -> b
kotlin.random.jdk8.PlatformThreadLocalRandom -> d0.a:
    java.util.Random getImpl() -> c
kotlin.ranges.IntProgression -> e0.a:
    kotlin.ranges.IntProgression$Companion Companion -> g
    int step -> f
    int first -> d
    int last -> e
    int getFirst() -> a
    int getLast() -> b
    int getStep() -> c
    kotlin.collections.IntIterator iterator() -> d
kotlin.ranges.IntProgression$Companion -> e0.a$a:
    kotlin.ranges.IntProgression fromClosedRange(int,int,int) -> a
kotlin.ranges.IntProgressionIterator -> e0.b:
    boolean hasNext -> f
    int next -> g
    int step -> d
    int finalElement -> e
kotlin.ranges.IntRange -> e0.c:
    kotlin.ranges.IntRange$Companion Companion -> h
    kotlin.ranges.IntRange EMPTY -> i
kotlin.ranges.IntRange$Companion -> e0.c$a:
kotlin.ranges.RangesKt -> e0.d:
    int coerceAtLeast(int,int) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    long coerceAtLeast(long,long) -> b
      # {"id":"com.android.tools.r8.synthesized"}
    int coerceAtMost(int,int) -> c
      # {"id":"com.android.tools.r8.synthesized"}
    long coerceAtMost(long,long) -> d
      # {"id":"com.android.tools.r8.synthesized"}
    kotlin.ranges.IntProgression downTo(int,int) -> e
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.ranges.RangesKt__RangesKt -> e0.e:
kotlin.ranges.RangesKt___RangesKt -> e0.f:
    int coerceAtLeast(int,int) -> a
    long coerceAtLeast(long,long) -> b
    int coerceAtMost(int,int) -> c
    long coerceAtMost(long,long) -> d
    kotlin.ranges.IntProgression downTo(int,int) -> e
kotlin.reflect.KCallable -> f0.a:
kotlin.reflect.KClass -> f0.b:
kotlin.reflect.KDeclarationContainer -> f0.c:
kotlin.reflect.KProperty -> f0.e:
kotlin.reflect.KProperty0 -> f0.d:
kotlin.sequences.ConstrainedOnceSequence -> g0.a:
    java.util.concurrent.atomic.AtomicReference sequenceRef -> a
kotlin.sequences.Sequence -> g0.b:
kotlin.sequences.SequencesKt -> g0.c:
    kotlin.sequences.Sequence asSequence(java.util.Iterator) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    java.util.List toList(kotlin.sequences.Sequence) -> d
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.sequences.SequencesKt__SequenceBuilderKt -> g0.d:
kotlin.sequences.SequencesKt__SequencesJVMKt -> g0.e:
kotlin.sequences.SequencesKt__SequencesKt -> g0.f:
    kotlin.sequences.Sequence asSequence(java.util.Iterator) -> a
    kotlin.sequences.Sequence constrainOnce(kotlin.sequences.Sequence) -> b
kotlin.sequences.SequencesKt__SequencesKt$asSequence$$inlined$Sequence$1 -> g0.f$a:
    java.util.Iterator $this_asSequence$inlined -> a
kotlin.sequences.SequencesKt___SequencesJvmKt -> g0.g:
kotlin.sequences.SequencesKt___SequencesKt -> g0.h:
    java.util.Collection toCollection(kotlin.sequences.Sequence,java.util.Collection) -> c
    java.util.List toList(kotlin.sequences.Sequence) -> d
    java.util.List toMutableList(kotlin.sequences.Sequence) -> e
kotlin.text.CharsKt__CharJVMKt -> h0.a:
    int checkRadix(int) -> a
    int digitOf(char,int) -> b
    boolean isWhitespace(char) -> c
kotlin.text.CharsKt__CharKt -> h0.b:
    boolean equals(char,char,boolean) -> d
kotlin.text.StringsKt -> h0.c:
    java.lang.Long toLongOrNull(java.lang.String) -> a
      # {"id":"com.android.tools.r8.synthesized"}
    boolean startsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> e
      # {"id":"com.android.tools.r8.synthesized"}
    int indexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> k
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfter$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> s
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringAfterLast$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> u
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringBefore$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> x
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.String substringBefore$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> y
      # {"id":"com.android.tools.r8.synthesized"}
    java.lang.CharSequence trim(java.lang.CharSequence) -> z
      # {"id":"com.android.tools.r8.synthesized"}
kotlin.text.StringsKt__AppendableKt -> h0.d:
kotlin.text.StringsKt__IndentKt -> h0.e:
kotlin.text.StringsKt__RegexExtensionsJVMKt -> h0.f:
kotlin.text.StringsKt__RegexExtensionsKt -> h0.g:
kotlin.text.StringsKt__StringBuilderJVMKt -> h0.h:
kotlin.text.StringsKt__StringBuilderKt -> h0.i:
kotlin.text.StringsKt__StringNumberConversionsJVMKt -> h0.j:
kotlin.text.StringsKt__StringNumberConversionsKt -> h0.k:
    java.lang.Long toLongOrNull(java.lang.String) -> a
    java.lang.Long toLongOrNull(java.lang.String,int) -> b
kotlin.text.StringsKt__StringsJVMKt -> h0.l:
    boolean regionMatches(java.lang.String,int,java.lang.String,int,int,boolean) -> c
    boolean startsWith(java.lang.String,java.lang.String,boolean) -> d
    boolean startsWith$default(java.lang.String,java.lang.String,boolean,int,java.lang.Object) -> e
kotlin.text.StringsKt__StringsKt -> h0.m:
    int getLastIndex(java.lang.CharSequence) -> f
    int indexOf(java.lang.CharSequence,char,int,boolean) -> g
    int indexOf(java.lang.CharSequence,java.lang.String,int,boolean) -> h
    int indexOf$StringsKt__StringsKt(java.lang.CharSequence,java.lang.CharSequence,int,int,boolean,boolean) -> i
    int indexOf$StringsKt__StringsKt$default(java.lang.CharSequence,java.lang.CharSequence,int,int,boolean,boolean,int,java.lang.Object) -> j
    int indexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> k
    int indexOf$default(java.lang.CharSequence,java.lang.String,int,boolean,int,java.lang.Object) -> l
    int indexOfAny(java.lang.CharSequence,char[],int,boolean) -> m
    int lastIndexOf(java.lang.CharSequence,char,int,boolean) -> n
    int lastIndexOf$default(java.lang.CharSequence,char,int,boolean,int,java.lang.Object) -> o
    int lastIndexOfAny(java.lang.CharSequence,char[],int,boolean) -> p
    boolean regionMatchesImpl(java.lang.CharSequence,int,java.lang.CharSequence,int,int,boolean) -> q
    java.lang.String substringAfter(java.lang.String,java.lang.String,java.lang.String) -> r
    java.lang.String substringAfter$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> s
    java.lang.String substringAfterLast(java.lang.String,char,java.lang.String) -> t
    java.lang.String substringAfterLast$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> u
    java.lang.String substringBefore(java.lang.String,char,java.lang.String) -> v
    java.lang.String substringBefore(java.lang.String,java.lang.String,java.lang.String) -> w
    java.lang.String substringBefore$default(java.lang.String,char,java.lang.String,int,java.lang.Object) -> x
    java.lang.String substringBefore$default(java.lang.String,java.lang.String,java.lang.String,int,java.lang.Object) -> y
    java.lang.CharSequence trim(java.lang.CharSequence) -> z
kotlin.text.StringsKt___StringsJvmKt -> h0.n:
kotlin.text.StringsKt___StringsKt -> h0.o:
kotlinx.coroutines.AbstractCoroutine -> i0.a:
    kotlin.coroutines.CoroutineContext context -> e
    void handleOnCompletionException$kotlinx_coroutines_core(java.lang.Throwable) -> L
    java.lang.String nameString$kotlinx_coroutines_core() -> Q
    void onCompletionInternal(java.lang.Object) -> V
    boolean isActive() -> a
    kotlin.coroutines.CoroutineContext getContext() -> c
    void resumeWith(java.lang.Object) -> h
    void afterResume(java.lang.Object) -> j0
    void onCancelled(java.lang.Throwable,boolean) -> k0
    void onCompleted(java.lang.Object) -> l0
    java.lang.String cancellationExceptionMessage() -> w
kotlinx.coroutines.AbstractTimeSource -> i0.b:
kotlinx.coroutines.AbstractTimeSourceKt -> i0.c:
    kotlinx.coroutines.AbstractTimeSource getTimeSource() -> a
kotlinx.coroutines.BlockingEventLoop -> i0.d:
    java.lang.Thread thread -> j
    java.lang.Thread getThread() -> w
kotlinx.coroutines.CancelHandler -> i0.e:
kotlinx.coroutines.CancelHandlerBase -> i0.f:
    void invoke(java.lang.Throwable) -> a
kotlinx.coroutines.CancellableContinuation -> i0.g:
kotlinx.coroutines.CancellableContinuationImpl -> i0.i:
    kotlin.coroutines.CoroutineContext context -> h
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _decision$FU -> j
    kotlin.coroutines.Continuation delegate -> g
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _state$FU -> k
    kotlinx.coroutines.DisposableHandle parentHandle -> i
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    kotlin.coroutines.CoroutineContext getContext() -> c
    java.lang.Throwable getExceptionalResult$kotlinx_coroutines_core(java.lang.Object) -> d
    java.lang.Object getSuccessfulResult$kotlinx_coroutines_core(java.lang.Object) -> e
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> g
    void resumeWith(java.lang.Object) -> h
    java.lang.Object takeState$kotlinx_coroutines_core() -> i
    java.lang.Void alreadyResumedError(java.lang.Object) -> j
    void callCancelHandler(kotlinx.coroutines.CancelHandler,java.lang.Throwable) -> k
    void callOnCancellation(kotlin.jvm.functions.Function1,java.lang.Throwable) -> l
    void detachChild$kotlinx_coroutines_core() -> m
    void detachChildIfNonResuable() -> n
    void dispatchResume(int) -> o
    java.lang.Object getState$kotlinx_coroutines_core() -> p
    java.lang.String getStateDebugRepresentation() -> q
    boolean isReusable() -> r
    java.lang.String nameString() -> s
    void resumeImpl(java.lang.Object,int,kotlin.jvm.functions.Function1) -> t
    void resumeImpl$default(kotlinx.coroutines.CancellableContinuationImpl,java.lang.Object,int,kotlin.jvm.functions.Function1,int,java.lang.Object) -> u
    java.lang.Object resumedState(kotlinx.coroutines.NotCompleted,java.lang.Object,int,kotlin.jvm.functions.Function1,java.lang.Object) -> v
    boolean tryResume() -> w
kotlinx.coroutines.CancellableContinuationImpl$$ExternalSyntheticBackportWithForwarding0 -> i0.h:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean kotlinx.coroutines.CancellableContinuationImpl$$InternalSyntheticBackportWithForwarding$1$14938e86c53bbc417d960c3db093d9c528eee461fa47b6759be891f884702045$0.m(java.util.concurrent.atomic.AtomicReferenceFieldUpdater,java.lang.Object,java.lang.Object,java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
kotlinx.coroutines.CancelledContinuation -> i0.j:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _resumed$FU -> c
    boolean makeResumed() -> c
kotlinx.coroutines.ChildHandle -> i0.k:
    boolean childCancelled(java.lang.Throwable) -> d
kotlinx.coroutines.ChildHandleNode -> i0.l:
    kotlinx.coroutines.ChildJob childJob -> h
    boolean childCancelled(java.lang.Throwable) -> d
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.ChildJob -> i0.m:
    void parentCancelled(kotlinx.coroutines.ParentJob) -> b
kotlinx.coroutines.CompletedContinuation -> i0.n:
    kotlinx.coroutines.CancelHandler cancelHandler -> b
    java.lang.Object idempotentResume -> d
    java.lang.Object result -> a
    java.lang.Throwable cancelCause -> e
    kotlin.jvm.functions.Function1 onCancellation -> c
    kotlinx.coroutines.CompletedContinuation copy(java.lang.Object,kotlinx.coroutines.CancelHandler,kotlin.jvm.functions.Function1,java.lang.Object,java.lang.Throwable) -> a
    kotlinx.coroutines.CompletedContinuation copy$default(kotlinx.coroutines.CompletedContinuation,java.lang.Object,kotlinx.coroutines.CancelHandler,kotlin.jvm.functions.Function1,java.lang.Object,java.lang.Throwable,int,java.lang.Object) -> b
    boolean getCancelled() -> c
    void invokeHandlers(kotlinx.coroutines.CancellableContinuationImpl,java.lang.Throwable) -> d
kotlinx.coroutines.CompletedExceptionally -> i0.o:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _handled$FU -> b
    java.lang.Throwable cause -> a
    boolean getHandled() -> a
    boolean makeHandled() -> b
kotlinx.coroutines.CompletedWithCancellation -> i0.p:
    java.lang.Object result -> a
    kotlin.jvm.functions.Function1 onCancellation -> b
kotlinx.coroutines.CompletionHandlerBase -> i0.q:
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.CompletionHandlerException -> i0.r:
kotlinx.coroutines.CompletionStateKt -> i0.s:
    java.lang.Object recoverResult(java.lang.Object,kotlin.coroutines.Continuation) -> a
    java.lang.Object toState(java.lang.Object,kotlin.jvm.functions.Function1) -> b
    java.lang.Object toState(java.lang.Object,kotlinx.coroutines.CancellableContinuation) -> c
    java.lang.Object toState$default(java.lang.Object,kotlin.jvm.functions.Function1,int,java.lang.Object) -> d
kotlinx.coroutines.CoroutineContextKt -> i0.t:
    java.lang.String getCoroutineName(kotlin.coroutines.CoroutineContext) -> a
    kotlinx.coroutines.UndispatchedCoroutine undispatchedCompletion(kotlin.coroutines.jvm.internal.CoroutineStackFrame) -> b
    kotlinx.coroutines.UndispatchedCoroutine updateUndispatchedCompletion(kotlin.coroutines.Continuation,kotlin.coroutines.CoroutineContext,java.lang.Object) -> c
kotlinx.coroutines.CoroutineDispatcher -> i0.u:
    kotlinx.coroutines.CoroutineDispatcher$Key Key -> d
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    kotlin.coroutines.Continuation interceptContinuation(kotlin.coroutines.Continuation) -> f
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> g
    kotlinx.coroutines.CoroutineDispatcher limitedParallelism(int) -> h
    void releaseInterceptedContinuation(kotlin.coroutines.Continuation) -> k
kotlinx.coroutines.CoroutineDispatcher$Key -> i0.u$a:
kotlinx.coroutines.CoroutineDispatcher$Key$1 -> i0.u$a$a:
    kotlinx.coroutines.CoroutineDispatcher$Key$1 INSTANCE -> e
    kotlinx.coroutines.CoroutineDispatcher invoke(kotlin.coroutines.CoroutineContext$Element) -> b
    java.lang.Object invoke(java.lang.Object) -> e
kotlinx.coroutines.CoroutineExceptionHandler -> i0.v:
    kotlinx.coroutines.CoroutineExceptionHandler$Key Key -> a
kotlinx.coroutines.CoroutineExceptionHandler$Key -> i0.v$a:
    kotlinx.coroutines.CoroutineExceptionHandler$Key $$INSTANCE -> d
kotlinx.coroutines.CoroutineExceptionHandlerImplKt -> i0.w:
    java.util.List handlers -> a
    void handleCoroutineExceptionImpl(kotlin.coroutines.CoroutineContext,java.lang.Throwable) -> a
kotlinx.coroutines.CoroutineExceptionHandlerKt -> i0.x:
    void handleCoroutineException(kotlin.coroutines.CoroutineContext,java.lang.Throwable) -> a
    java.lang.Throwable handlerException(java.lang.Throwable,java.lang.Throwable) -> b
kotlinx.coroutines.CoroutinesInternalError -> i0.y:
kotlinx.coroutines.DebugStringsKt -> i0.z:
    java.lang.String getClassSimpleName(java.lang.Object) -> a
    java.lang.String getHexAddress(java.lang.Object) -> b
    java.lang.String toDebugString(kotlin.coroutines.Continuation) -> c
kotlinx.coroutines.DefaultExecutor -> i0.a0:
    kotlinx.coroutines.DefaultExecutor INSTANCE -> j
    long KEEP_ALIVE_NANOS -> k
    void enqueue(java.lang.Runnable) -> C
    void acknowledgeShutdownIfNeeded() -> N
    java.lang.Thread createThreadSync() -> O
    boolean isShutDown() -> P
    boolean isShutdownRequested() -> Q
    boolean notifyStartup() -> R
    void shutdownError() -> S
    java.lang.Thread getThread() -> w
    void reschedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> x
kotlinx.coroutines.DefaultExecutorKt -> i0.b0:
    kotlinx.coroutines.Delay DefaultDelay -> b
    boolean defaultMainDelayOptIn -> a
    kotlinx.coroutines.Delay getDefaultDelay() -> a
    kotlinx.coroutines.Delay initializeDefaultDelay() -> b
kotlinx.coroutines.Delay -> i0.c0:
kotlinx.coroutines.DiagnosticCoroutineContextException -> i0.d0:
    kotlin.coroutines.CoroutineContext context -> d
kotlinx.coroutines.DispatchedCoroutine -> i0.e0:
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _decision$FU -> g
    void afterResume(java.lang.Object) -> j0
    boolean tryResume() -> m0
    void afterCompletion(java.lang.Object) -> r
kotlinx.coroutines.DispatchedTask -> i0.f0:
    int resumeMode -> f
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    java.lang.Throwable getExceptionalResult$kotlinx_coroutines_core(java.lang.Object) -> d
    java.lang.Object getSuccessfulResult$kotlinx_coroutines_core(java.lang.Object) -> e
    void handleFatalException(java.lang.Throwable,java.lang.Throwable) -> f
    java.lang.Object takeState$kotlinx_coroutines_core() -> i
kotlinx.coroutines.DispatchedTaskKt -> i0.g0:
    void dispatch(kotlinx.coroutines.DispatchedTask,int) -> a
    boolean isCancellableMode(int) -> b
    boolean isReusableMode(int) -> c
    void resume(kotlinx.coroutines.DispatchedTask,kotlin.coroutines.Continuation,boolean) -> d
    void resumeUnconfined(kotlinx.coroutines.DispatchedTask) -> e
kotlinx.coroutines.Dispatchers -> i0.h0:
    kotlinx.coroutines.Dispatchers INSTANCE -> a
    kotlinx.coroutines.CoroutineDispatcher IO -> d
    kotlinx.coroutines.CoroutineDispatcher Unconfined -> c
    kotlinx.coroutines.CoroutineDispatcher Default -> b
    kotlinx.coroutines.CoroutineDispatcher getIO() -> a
    kotlinx.coroutines.MainCoroutineDispatcher getMain() -> b
kotlinx.coroutines.DisposableHandle -> i0.i0:
    void dispose() -> b
kotlinx.coroutines.Empty -> i0.j0:
    boolean isActive -> d
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> c
kotlinx.coroutines.EventLoop -> i0.k0:
    long useCount -> e
    boolean shared -> f
    kotlinx.coroutines.internal.ArrayQueue unconfinedQueue -> g
    void decrementUseCount(boolean) -> n
    long delta(boolean) -> o
    void dispatchUnconfined(kotlinx.coroutines.DispatchedTask) -> p
    long getNextTime() -> q
    void incrementUseCount(boolean) -> r
    void incrementUseCount$default(kotlinx.coroutines.EventLoop,boolean,int,java.lang.Object) -> s
    boolean isUnconfinedLoopActive() -> t
    boolean isUnconfinedQueueEmpty() -> u
    boolean processUnconfinedEvent() -> v
kotlinx.coroutines.EventLoopImplBase -> i0.l0:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _queue$FU -> h
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _delayed$FU -> i
    void closeQueue() -> A
    java.lang.Runnable dequeue() -> B
    void enqueue(java.lang.Runnable) -> C
    boolean enqueueImpl(java.lang.Runnable) -> D
    boolean isCompleted() -> E
    boolean isEmpty() -> F
    long processNextEvent() -> G
    void rescheduleAllDelayed() -> H
    void resetAll() -> I
    void schedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> J
    int scheduleImpl(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> K
    void setCompleted(boolean) -> L
    boolean shouldUnpark(kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> M
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    long getNextTime() -> q
    boolean access$isCompleted(kotlinx.coroutines.EventLoopImplBase) -> z
kotlinx.coroutines.EventLoopImplBase$DelayedTask -> i0.l0$a:
    java.lang.Object _heap -> e
    int index -> f
    long nanoTime -> d
    void setIndex(int) -> a
    void dispose() -> b
    void setHeap(kotlinx.coroutines.internal.ThreadSafeHeap) -> c
    kotlinx.coroutines.internal.ThreadSafeHeap getHeap() -> e
    int getIndex() -> f
    int compareTo(kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> g
    int scheduleTask(long,kotlinx.coroutines.EventLoopImplBase$DelayedTaskQueue,kotlinx.coroutines.EventLoopImplBase) -> h
    boolean timeToExecute(long) -> i
kotlinx.coroutines.EventLoopImplBase$DelayedTaskQueue -> i0.l0$b:
    long timeNow -> b
kotlinx.coroutines.EventLoopImplPlatform -> i0.m0:
    java.lang.Thread getThread() -> w
    void reschedule(long,kotlinx.coroutines.EventLoopImplBase$DelayedTask) -> x
    void unpark() -> y
kotlinx.coroutines.EventLoopKt -> i0.n0:
    kotlinx.coroutines.EventLoop createEventLoop() -> a
kotlinx.coroutines.EventLoop_commonKt -> i0.o0:
    kotlinx.coroutines.internal.Symbol DISPOSED_TASK -> a
    kotlinx.coroutines.internal.Symbol CLOSED_EMPTY -> b
    kotlinx.coroutines.internal.Symbol access$getCLOSED_EMPTY$p() -> a
    kotlinx.coroutines.internal.Symbol access$getDISPOSED_TASK$p() -> b
kotlinx.coroutines.ExecutorCoroutineDispatcher -> i0.p0:
    kotlinx.coroutines.ExecutorCoroutineDispatcher$Key Key -> e
kotlinx.coroutines.ExecutorCoroutineDispatcher$Key -> i0.p0$a:
kotlinx.coroutines.ExecutorCoroutineDispatcher$Key$1 -> i0.p0$a$a:
    kotlinx.coroutines.ExecutorCoroutineDispatcher$Key$1 INSTANCE -> e
    kotlinx.coroutines.ExecutorCoroutineDispatcher invoke(kotlin.coroutines.CoroutineContext$Element) -> b
    java.lang.Object invoke(java.lang.Object) -> e
kotlinx.coroutines.InactiveNodeList -> i0.q0:
    kotlinx.coroutines.NodeList list -> d
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> c
kotlinx.coroutines.Incomplete -> i0.r0:
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> c
kotlinx.coroutines.IncompleteStateBox -> i0.s0:
    kotlinx.coroutines.Incomplete state -> a
kotlinx.coroutines.InvokeOnCancelling -> i0.t0:
    kotlin.jvm.functions.Function1 handler -> h
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _invoked$FU -> i
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.InvokeOnCompletion -> i0.u0:
    kotlin.jvm.functions.Function1 handler -> h
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.Job -> i0.v0:
    kotlinx.coroutines.Job$Key Key -> b
    boolean isActive() -> a
    java.util.concurrent.CancellationException getCancellationException() -> e
    void cancel(java.util.concurrent.CancellationException) -> j
    kotlinx.coroutines.DisposableHandle invokeOnCompletion(boolean,boolean,kotlin.jvm.functions.Function1) -> l
kotlinx.coroutines.Job$DefaultImpls -> i0.v0$a:
    java.lang.Object fold(kotlinx.coroutines.Job,java.lang.Object,kotlin.jvm.functions.Function2) -> a
    kotlin.coroutines.CoroutineContext$Element get(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext$Key) -> b
    kotlinx.coroutines.DisposableHandle invokeOnCompletion$default(kotlinx.coroutines.Job,boolean,boolean,kotlin.jvm.functions.Function1,int,java.lang.Object) -> c
    kotlin.coroutines.CoroutineContext minusKey(kotlinx.coroutines.Job,kotlin.coroutines.CoroutineContext$Key) -> d
kotlinx.coroutines.Job$Key -> i0.v0$b:
    kotlinx.coroutines.Job$Key $$INSTANCE -> d
kotlinx.coroutines.JobCancellationException -> i0.w0:
    kotlinx.coroutines.Job job -> d
kotlinx.coroutines.JobCancellingNode -> i0.x0:
kotlinx.coroutines.JobKt -> i0.y0:
    void cancel(kotlin.coroutines.CoroutineContext,java.util.concurrent.CancellationException) -> a
kotlinx.coroutines.JobKt__JobKt -> i0.z0:
    void cancel(kotlin.coroutines.CoroutineContext,java.util.concurrent.CancellationException) -> a
kotlinx.coroutines.JobNode -> i0.a1:
    kotlinx.coroutines.JobSupport job -> g
    boolean isActive() -> a
    void dispose() -> b
    kotlinx.coroutines.NodeList getList() -> c
    kotlinx.coroutines.JobSupport getJob() -> t
    void setJob(kotlinx.coroutines.JobSupport) -> u
kotlinx.coroutines.JobSupport -> i0.b1:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _state$FU -> d
    java.lang.Throwable createCauseException(java.lang.Object) -> A
    java.lang.Object finalizeFinishingState(kotlinx.coroutines.JobSupport$Finishing,java.lang.Object) -> B
    kotlinx.coroutines.ChildHandleNode firstChild(kotlinx.coroutines.Incomplete) -> C
    java.lang.Throwable getExceptionOrNull(java.lang.Object) -> D
    java.lang.Throwable getFinalRootCause(kotlinx.coroutines.JobSupport$Finishing,java.util.List) -> E
    boolean getHandlesException$kotlinx_coroutines_core() -> F
    boolean getOnCancelComplete$kotlinx_coroutines_core() -> G
    kotlinx.coroutines.NodeList getOrPromoteCancellingList(kotlinx.coroutines.Incomplete) -> H
    kotlinx.coroutines.ChildHandle getParentHandle$kotlinx_coroutines_core() -> I
    java.lang.Object getState$kotlinx_coroutines_core() -> J
    boolean handleJobException(java.lang.Throwable) -> K
    void handleOnCompletionException$kotlinx_coroutines_core(java.lang.Throwable) -> L
    boolean isScopedCoroutine() -> M
    java.lang.Object makeCancelling(java.lang.Object) -> N
    java.lang.Object makeCompletingOnce$kotlinx_coroutines_core(java.lang.Object) -> O
    kotlinx.coroutines.JobNode makeNode(kotlin.jvm.functions.Function1,boolean) -> P
    java.lang.String nameString$kotlinx_coroutines_core() -> Q
    kotlinx.coroutines.ChildHandleNode nextChild(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> R
    void notifyCancelling(kotlinx.coroutines.NodeList,java.lang.Throwable) -> S
    void notifyCompletion(kotlinx.coroutines.NodeList,java.lang.Throwable) -> T
    void onCancelling(java.lang.Throwable) -> U
    void onCompletionInternal(java.lang.Object) -> V
    void promoteEmptyToNodeList(kotlinx.coroutines.Empty) -> W
    void promoteSingleToNodeList(kotlinx.coroutines.JobNode) -> X
    void removeNode$kotlinx_coroutines_core(kotlinx.coroutines.JobNode) -> Y
    void setParentHandle$kotlinx_coroutines_core(kotlinx.coroutines.ChildHandle) -> Z
    boolean isActive() -> a
    java.lang.String stateString(java.lang.Object) -> a0
    void parentCancelled(kotlinx.coroutines.ParentJob) -> b
    java.util.concurrent.CancellationException toCancellationException(java.lang.Throwable,java.lang.String) -> b0
    java.util.concurrent.CancellationException toCancellationException$default(kotlinx.coroutines.JobSupport,java.lang.Throwable,java.lang.String,int,java.lang.Object) -> c0
    java.util.concurrent.CancellationException getChildJobCancellationCause() -> d
    java.lang.String toDebugString() -> d0
    java.util.concurrent.CancellationException getCancellationException() -> e
    boolean tryFinalizeSimpleState(kotlinx.coroutines.Incomplete,java.lang.Object) -> e0
    boolean tryMakeCancelling(kotlinx.coroutines.Incomplete,java.lang.Throwable) -> f0
    java.lang.Object tryMakeCompleting(java.lang.Object,java.lang.Object) -> g0
    java.lang.Object tryMakeCompletingSlowPath(kotlinx.coroutines.Incomplete,java.lang.Object) -> h0
    boolean tryWaitForChild(kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> i0
    void cancel(java.util.concurrent.CancellationException) -> j
    kotlinx.coroutines.DisposableHandle invokeOnCompletion(boolean,boolean,kotlin.jvm.functions.Function1) -> l
    java.lang.String access$cancellationExceptionMessage(kotlinx.coroutines.JobSupport) -> n
    void access$continueCompleting(kotlinx.coroutines.JobSupport,kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> o
    boolean addLastAtomic(java.lang.Object,kotlinx.coroutines.NodeList,kotlinx.coroutines.JobNode) -> p
    void addSuppressedExceptions(java.lang.Throwable,java.util.List) -> q
    void afterCompletion(java.lang.Object) -> r
    boolean cancelImpl$kotlinx_coroutines_core(java.lang.Object) -> s
    void cancelInternal(java.lang.Throwable) -> t
    java.lang.Object cancelMakeCompleting(java.lang.Object) -> u
    boolean cancelParent(java.lang.Throwable) -> v
    java.lang.String cancellationExceptionMessage() -> w
    boolean childCancelled(java.lang.Throwable) -> x
    void completeStateFinalization(kotlinx.coroutines.Incomplete,java.lang.Object) -> y
    void continueCompleting(kotlinx.coroutines.JobSupport$Finishing,kotlinx.coroutines.ChildHandleNode,java.lang.Object) -> z
kotlinx.coroutines.JobSupport$ChildCompletion -> i0.b1$a:
    java.lang.Object proposedUpdate -> k
    kotlinx.coroutines.JobSupport$Finishing state -> i
    kotlinx.coroutines.ChildHandleNode child -> j
    kotlinx.coroutines.JobSupport parent -> h
    java.lang.Object invoke(java.lang.Object) -> e
    void invoke(java.lang.Throwable) -> s
kotlinx.coroutines.JobSupport$Finishing -> i0.b1$b:
    kotlinx.coroutines.NodeList list -> d
    boolean isActive() -> a
    void addExceptionLocked(java.lang.Throwable) -> b
    kotlinx.coroutines.NodeList getList() -> c
    java.util.ArrayList allocateList() -> d
    java.lang.Object getExceptionsHolder() -> e
    java.lang.Throwable getRootCause() -> f
    boolean isCancelling() -> g
    boolean isCompleting() -> h
    boolean isSealed() -> i
    java.util.List sealLocked(java.lang.Throwable) -> j
    void setCompleting(boolean) -> k
    void setExceptionsHolder(java.lang.Object) -> l
    void setRootCause(java.lang.Throwable) -> m
kotlinx.coroutines.JobSupport$addLastAtomic$$inlined$addLastIf$1 -> i0.b1$c:
    kotlinx.coroutines.JobSupport this$0 -> e
    java.lang.Object $expect$inlined -> f
    kotlinx.coroutines.internal.LockFreeLinkedListNode $node -> d
    java.lang.Object prepare(java.lang.Object) -> g
    java.lang.Object prepare(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
kotlinx.coroutines.JobSupportKt -> i0.c1:
    kotlinx.coroutines.internal.Symbol COMPLETING_ALREADY -> a
    kotlinx.coroutines.internal.Symbol TOO_LATE_TO_CANCEL -> d
    kotlinx.coroutines.internal.Symbol SEALED -> e
    kotlinx.coroutines.internal.Symbol COMPLETING_WAITING_CHILDREN -> b
    kotlinx.coroutines.internal.Symbol COMPLETING_RETRY -> c
    kotlinx.coroutines.Empty EMPTY_NEW -> f
    kotlinx.coroutines.Empty EMPTY_ACTIVE -> g
    kotlinx.coroutines.internal.Symbol access$getCOMPLETING_ALREADY$p() -> a
    kotlinx.coroutines.internal.Symbol access$getCOMPLETING_RETRY$p() -> b
    kotlinx.coroutines.Empty access$getEMPTY_ACTIVE$p() -> c
    kotlinx.coroutines.internal.Symbol access$getSEALED$p() -> d
    kotlinx.coroutines.internal.Symbol access$getTOO_LATE_TO_CANCEL$p() -> e
    java.lang.Object boxIncomplete(java.lang.Object) -> f
kotlinx.coroutines.MainCoroutineDispatcher -> i0.d1:
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> n
    java.lang.String toStringInternalImpl() -> o
kotlinx.coroutines.NodeList -> i0.e1:
    boolean isActive() -> a
    kotlinx.coroutines.NodeList getList() -> c
kotlinx.coroutines.NonDisposableHandle -> i0.f1:
    kotlinx.coroutines.NonDisposableHandle INSTANCE -> d
    void dispose() -> b
    boolean childCancelled(java.lang.Throwable) -> d
kotlinx.coroutines.NotCompleted -> i0.g1:
kotlinx.coroutines.ParentJob -> i0.h1:
    java.util.concurrent.CancellationException getChildJobCancellationCause() -> d
kotlinx.coroutines.ThreadContextElement -> i0.i1:
    void restoreThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> i
    java.lang.Object updateThreadContext(kotlin.coroutines.CoroutineContext) -> m
kotlinx.coroutines.ThreadLocalEventLoop -> i0.j1:
    kotlinx.coroutines.ThreadLocalEventLoop INSTANCE -> a
    java.lang.ThreadLocal ref -> b
    kotlinx.coroutines.EventLoop getEventLoop$kotlinx_coroutines_core() -> a
    void resetEventLoop$kotlinx_coroutines_core() -> b
    void setEventLoop$kotlinx_coroutines_core(kotlinx.coroutines.EventLoop) -> c
kotlinx.coroutines.Unconfined -> i0.k1:
    kotlinx.coroutines.Unconfined INSTANCE -> e
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> g
kotlinx.coroutines.UndispatchedCoroutine -> i0.l1:
    java.lang.ThreadLocal threadStateToRecover -> g
    void afterResume(java.lang.Object) -> j0
    boolean clearThreadContext() -> m0
    void saveThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> n0
kotlinx.coroutines.UndispatchedMarker -> i0.m1:
    kotlinx.coroutines.UndispatchedMarker INSTANCE -> d
kotlinx.coroutines.YieldContext -> i0.n1:
    kotlinx.coroutines.YieldContext$Key Key -> e
    boolean dispatcherWasUnconfined -> d
kotlinx.coroutines.YieldContext$Key -> i0.n1$a:
kotlinx.coroutines.android.HandlerContext -> j0.a:
    java.lang.String name -> f
    android.os.Handler handler -> e
    boolean invokeImmediately -> g
    kotlinx.coroutines.android.HandlerContext immediate -> h
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> g
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> n
    void cancelOnRejection(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> p
    kotlinx.coroutines.android.HandlerContext getImmediate() -> q
kotlinx.coroutines.android.HandlerDispatcher -> j0.b:
kotlinx.coroutines.android.HandlerDispatcherKt -> j0.c:
    kotlinx.coroutines.android.HandlerDispatcher Main -> a
    android.os.Handler asHandler(android.os.Looper,boolean) -> a
kotlinx.coroutines.internal.ArrayQueue -> kotlinx.coroutines.internal.a:
    java.lang.Object[] elements -> a
    int head -> b
    int tail -> c
    void addLast(java.lang.Object) -> a
    void ensureCapacity() -> b
    boolean isEmpty() -> c
    java.lang.Object removeFirstOrNull() -> d
kotlinx.coroutines.internal.AtomicKt -> kotlinx.coroutines.internal.b:
    java.lang.Object RETRY_ATOMIC -> b
    java.lang.Object NO_DECISION -> a
kotlinx.coroutines.internal.AtomicOp -> kotlinx.coroutines.internal.c:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _consensus$FU -> a
    kotlinx.coroutines.internal.AtomicOp getAtomicOp() -> a
    java.lang.Object perform(java.lang.Object) -> c
    void complete(java.lang.Object,java.lang.Object) -> d
    java.lang.Object decide(java.lang.Object) -> e
    long getOpSequence() -> f
    java.lang.Object prepare(java.lang.Object) -> g
kotlinx.coroutines.internal.DispatchedContinuation -> kotlinx.coroutines.internal.d:
    java.lang.Object countOrElement -> j
    java.lang.Object _state -> i
    kotlinx.coroutines.CoroutineDispatcher dispatcher -> g
    kotlin.coroutines.Continuation continuation -> h
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _reusableCancellableContinuation$FU -> k
    void cancelCompletedResult$kotlinx_coroutines_core(java.lang.Object,java.lang.Throwable) -> a
    kotlin.coroutines.Continuation getDelegate$kotlinx_coroutines_core() -> b
    kotlin.coroutines.CoroutineContext getContext() -> c
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> g
    void resumeWith(java.lang.Object) -> h
    java.lang.Object takeState$kotlinx_coroutines_core() -> i
    void awaitReusability() -> j
    kotlinx.coroutines.CancellableContinuationImpl getReusableCancellableContinuation() -> k
    boolean isReusable() -> l
    void release() -> m
kotlinx.coroutines.internal.DispatchedContinuationKt -> kotlinx.coroutines.internal.e:
    kotlinx.coroutines.internal.Symbol UNDEFINED -> a
    kotlinx.coroutines.internal.Symbol REUSABLE_CLAIMED -> b
    kotlinx.coroutines.internal.Symbol access$getUNDEFINED$p() -> a
    void resumeCancellableWith(kotlin.coroutines.Continuation,java.lang.Object,kotlin.jvm.functions.Function1) -> b
    void resumeCancellableWith$default(kotlin.coroutines.Continuation,java.lang.Object,kotlin.jvm.functions.Function1,int,java.lang.Object) -> c
kotlinx.coroutines.internal.FastServiceLoader -> kotlinx.coroutines.internal.f:
    kotlinx.coroutines.internal.FastServiceLoader INSTANCE -> a
    java.lang.Object getProviderInstance(java.lang.String,java.lang.ClassLoader,java.lang.Class) -> a
    java.util.List load(java.lang.Class,java.lang.ClassLoader) -> b
    java.util.List loadMainDispatcherFactory$kotlinx_coroutines_core() -> c
    java.util.List loadProviders$kotlinx_coroutines_core(java.lang.Class,java.lang.ClassLoader) -> d
    java.util.List parse(java.net.URL) -> e
    java.util.List parseFile(java.io.BufferedReader) -> f
kotlinx.coroutines.internal.FastServiceLoaderKt -> kotlinx.coroutines.internal.g:
    boolean ANDROID_DETECTED -> a
    boolean getANDROID_DETECTED() -> a
kotlinx.coroutines.internal.LimitedDispatcher -> kotlinx.coroutines.internal.h:
    java.lang.Object workerAllocationLock -> i
    kotlinx.coroutines.CoroutineDispatcher dispatcher -> e
    kotlinx.coroutines.internal.LockFreeTaskQueue queue -> h
    int parallelism -> f
    kotlinx.coroutines.Delay $$delegate_0 -> g
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean addAndTryDispatching(java.lang.Runnable) -> n
    boolean tryAllocateWorker() -> o
kotlinx.coroutines.internal.LimitedDispatcherKt -> kotlinx.coroutines.internal.i:
    void checkParallelism(int) -> a
kotlinx.coroutines.internal.LockFreeLinkedListHead -> kotlinx.coroutines.internal.j:
    boolean isRemoved() -> n
kotlinx.coroutines.internal.LockFreeLinkedListKt -> kotlinx.coroutines.internal.k:
    java.lang.Object LIST_EMPTY -> b
    java.lang.Object CONDITION_FALSE -> a
    java.lang.Object getCONDITION_FALSE() -> a
    kotlinx.coroutines.internal.LockFreeLinkedListNode unwrap(java.lang.Object) -> b
kotlinx.coroutines.internal.LockFreeLinkedListNode -> kotlinx.coroutines.internal.l:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _removedRef$FU -> f
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _next$FU -> d
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _prev$FU -> e
    void access$finishAdd(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode) -> f
    boolean addOneIfEmpty(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> g
    kotlinx.coroutines.internal.LockFreeLinkedListNode correctPrev(kotlinx.coroutines.internal.OpDescriptor) -> h
    kotlinx.coroutines.internal.LockFreeLinkedListNode findPrevNonRemoved(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> i
    void finishAdd(kotlinx.coroutines.internal.LockFreeLinkedListNode) -> j
    java.lang.Object getNext() -> k
    kotlinx.coroutines.internal.LockFreeLinkedListNode getNextNode() -> l
    kotlinx.coroutines.internal.LockFreeLinkedListNode getPrevNode() -> m
    boolean isRemoved() -> n
    boolean remove() -> o
    kotlinx.coroutines.internal.LockFreeLinkedListNode removeOrNext() -> p
    kotlinx.coroutines.internal.Removed removed() -> q
    int tryCondAddNext(kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode,kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp) -> r
kotlinx.coroutines.internal.LockFreeLinkedListNode$CondAddOp -> kotlinx.coroutines.internal.l$a:
    kotlinx.coroutines.internal.LockFreeLinkedListNode oldNext -> c
    kotlinx.coroutines.internal.LockFreeLinkedListNode newNode -> b
    void complete(java.lang.Object,java.lang.Object) -> d
    void complete(kotlinx.coroutines.internal.LockFreeLinkedListNode,java.lang.Object) -> h
kotlinx.coroutines.internal.LockFreeLinkedListNode$toString$1 -> kotlinx.coroutines.internal.l$b:
kotlinx.coroutines.internal.LockFreeTaskQueue -> kotlinx.coroutines.internal.m:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _cur$FU -> a
    boolean addLast(java.lang.Object) -> a
    void close() -> b
    int getSize() -> c
    java.lang.Object removeFirstOrNull() -> d
kotlinx.coroutines.internal.LockFreeTaskQueueCore -> kotlinx.coroutines.internal.n:
    java.util.concurrent.atomic.AtomicLongFieldUpdater _state$FU -> g
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater _next$FU -> f
    kotlinx.coroutines.internal.Symbol REMOVE_FROZEN -> h
    kotlinx.coroutines.internal.LockFreeTaskQueueCore$Companion Companion -> e
    java.util.concurrent.atomic.AtomicReferenceArray array -> d
    boolean singleConsumer -> b
    int mask -> c
    int capacity -> a
    int addLast(java.lang.Object) -> a
    kotlinx.coroutines.internal.LockFreeTaskQueueCore allocateNextCopy(long) -> b
    kotlinx.coroutines.internal.LockFreeTaskQueueCore allocateOrGetNextCopy(long) -> c
    boolean close() -> d
    kotlinx.coroutines.internal.LockFreeTaskQueueCore fillPlaceholder(int,java.lang.Object) -> e
    int getSize() -> f
    boolean isEmpty() -> g
    long markFrozen() -> h
    kotlinx.coroutines.internal.LockFreeTaskQueueCore next() -> i
    java.lang.Object removeFirstOrNull() -> j
    kotlinx.coroutines.internal.LockFreeTaskQueueCore removeSlowPath(int,int) -> k
kotlinx.coroutines.internal.LockFreeTaskQueueCore$Companion -> kotlinx.coroutines.internal.n$a:
    int addFailReason(long) -> a
    long updateHead(long,int) -> b
    long updateTail(long,int) -> c
    long wo(long,long) -> d
kotlinx.coroutines.internal.LockFreeTaskQueueCore$Placeholder -> kotlinx.coroutines.internal.n$b:
    int index -> a
kotlinx.coroutines.internal.MainDispatcherFactory -> kotlinx.coroutines.internal.o:
kotlinx.coroutines.internal.MainDispatcherLoader -> kotlinx.coroutines.internal.p:
    kotlinx.coroutines.internal.MainDispatcherLoader INSTANCE -> a
    kotlinx.coroutines.MainCoroutineDispatcher dispatcher -> c
    boolean FAST_SERVICE_LOADER_ENABLED -> b
    kotlinx.coroutines.MainCoroutineDispatcher loadMainDispatcher() -> a
kotlinx.coroutines.internal.MainDispatchersKt -> kotlinx.coroutines.internal.q:
    boolean SUPPORT_MISSING -> a
    kotlinx.coroutines.internal.MissingMainCoroutineDispatcher createMissingDispatcher(java.lang.Throwable,java.lang.String) -> a
    kotlinx.coroutines.internal.MissingMainCoroutineDispatcher createMissingDispatcher$default(java.lang.Throwable,java.lang.String,int,java.lang.Object) -> b
    boolean isMissing(kotlinx.coroutines.MainCoroutineDispatcher) -> c
    java.lang.Void throwMissingMainDispatcherException() -> d
    kotlinx.coroutines.MainCoroutineDispatcher tryCreateDispatcher(kotlinx.coroutines.internal.MainDispatcherFactory,java.util.List) -> e
kotlinx.coroutines.internal.MissingMainCoroutineDispatcher -> kotlinx.coroutines.internal.r:
    java.lang.String errorHint -> f
    java.lang.Throwable cause -> e
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    boolean isDispatchNeeded(kotlin.coroutines.CoroutineContext) -> g
    kotlinx.coroutines.MainCoroutineDispatcher getImmediate() -> n
    java.lang.Void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> p
    java.lang.Void missing() -> q
kotlinx.coroutines.internal.OpDescriptor -> kotlinx.coroutines.internal.s:
    kotlinx.coroutines.internal.AtomicOp getAtomicOp() -> a
    boolean isEarlierThan(kotlinx.coroutines.internal.OpDescriptor) -> b
    java.lang.Object perform(java.lang.Object) -> c
kotlinx.coroutines.internal.Removed -> kotlinx.coroutines.internal.t:
    kotlinx.coroutines.internal.LockFreeLinkedListNode ref -> a
kotlinx.coroutines.internal.ResizableAtomicArray -> kotlinx.coroutines.internal.u:
    int currentLength() -> a
    java.lang.Object get(int) -> b
    void setSynchronized(int,java.lang.Object) -> c
kotlinx.coroutines.internal.ScopeCoroutine -> kotlinx.coroutines.internal.v:
    kotlin.coroutines.Continuation uCont -> f
    boolean isScopedCoroutine() -> M
    kotlin.coroutines.jvm.internal.CoroutineStackFrame getCallerFrame() -> g
    void afterResume(java.lang.Object) -> j0
    void afterCompletion(java.lang.Object) -> r
kotlinx.coroutines.internal.Symbol -> kotlinx.coroutines.internal.w:
    java.lang.String symbol -> a
kotlinx.coroutines.internal.SystemPropsKt -> kotlinx.coroutines.internal.x:
    int getAVAILABLE_PROCESSORS() -> a
    int systemProp(java.lang.String,int,int,int) -> b
    long systemProp(java.lang.String,long,long,long) -> c
    java.lang.String systemProp(java.lang.String) -> d
    boolean systemProp(java.lang.String,boolean) -> e
    int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object) -> f
    long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object) -> g
kotlinx.coroutines.internal.SystemPropsKt__SystemPropsKt -> kotlinx.coroutines.internal.y:
    int AVAILABLE_PROCESSORS -> a
    int getAVAILABLE_PROCESSORS() -> a
    java.lang.String systemProp(java.lang.String) -> b
kotlinx.coroutines.internal.SystemPropsKt__SystemProps_commonKt -> kotlinx.coroutines.internal.z:
    int systemProp(java.lang.String,int,int,int) -> a
    long systemProp(java.lang.String,long,long,long) -> b
    boolean systemProp(java.lang.String,boolean) -> c
    int systemProp$default(java.lang.String,int,int,int,int,java.lang.Object) -> d
    long systemProp$default(java.lang.String,long,long,long,int,java.lang.Object) -> e
kotlinx.coroutines.internal.ThreadContextKt -> kotlinx.coroutines.internal.a0:
    kotlinx.coroutines.internal.Symbol NO_THREAD_ELEMENTS -> a
    kotlin.jvm.functions.Function2 findOne -> c
    kotlin.jvm.functions.Function2 countAll -> b
    kotlin.jvm.functions.Function2 updateState -> d
    void restoreThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> a
    java.lang.Object threadContextElements(kotlin.coroutines.CoroutineContext) -> b
    java.lang.Object updateThreadContext(kotlin.coroutines.CoroutineContext,java.lang.Object) -> c
kotlinx.coroutines.internal.ThreadContextKt$countAll$1 -> kotlinx.coroutines.internal.a0$a:
    kotlinx.coroutines.internal.ThreadContextKt$countAll$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    java.lang.Object invoke(java.lang.Object,kotlin.coroutines.CoroutineContext$Element) -> b
kotlinx.coroutines.internal.ThreadContextKt$findOne$1 -> kotlinx.coroutines.internal.a0$b:
    kotlinx.coroutines.internal.ThreadContextKt$findOne$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    kotlinx.coroutines.ThreadContextElement invoke(kotlinx.coroutines.ThreadContextElement,kotlin.coroutines.CoroutineContext$Element) -> b
kotlinx.coroutines.internal.ThreadContextKt$updateState$1 -> kotlinx.coroutines.internal.a0$c:
    kotlinx.coroutines.internal.ThreadContextKt$updateState$1 INSTANCE -> e
    java.lang.Object invoke(java.lang.Object,java.lang.Object) -> a
    kotlinx.coroutines.internal.ThreadState invoke(kotlinx.coroutines.internal.ThreadState,kotlin.coroutines.CoroutineContext$Element) -> b
kotlinx.coroutines.internal.ThreadSafeHeap -> kotlinx.coroutines.internal.b0:
    void addImpl(kotlinx.coroutines.internal.ThreadSafeHeapNode) -> a
    kotlinx.coroutines.internal.ThreadSafeHeapNode firstImpl() -> b
    int getSize() -> c
    boolean isEmpty() -> d
    kotlinx.coroutines.internal.ThreadSafeHeapNode peek() -> e
    kotlinx.coroutines.internal.ThreadSafeHeapNode[] realloc() -> f
    boolean remove(kotlinx.coroutines.internal.ThreadSafeHeapNode) -> g
    kotlinx.coroutines.internal.ThreadSafeHeapNode removeAtImpl(int) -> h
    kotlinx.coroutines.internal.ThreadSafeHeapNode removeFirstOrNull() -> i
    void setSize(int) -> j
    void siftDownFrom(int) -> k
    void siftUpFrom(int) -> l
    void swap(int,int) -> m
kotlinx.coroutines.internal.ThreadSafeHeapNode -> kotlinx.coroutines.internal.c0:
    void setIndex(int) -> a
    void setHeap(kotlinx.coroutines.internal.ThreadSafeHeap) -> c
    kotlinx.coroutines.internal.ThreadSafeHeap getHeap() -> e
    int getIndex() -> f
kotlinx.coroutines.internal.ThreadState -> kotlinx.coroutines.internal.d0:
    java.lang.Object[] values -> b
    kotlinx.coroutines.ThreadContextElement[] elements -> c
    int i -> d
    kotlin.coroutines.CoroutineContext context -> a
    void append(kotlinx.coroutines.ThreadContextElement,java.lang.Object) -> a
    void restore(kotlin.coroutines.CoroutineContext) -> b
kotlinx.coroutines.scheduling.CoroutineScheduler -> kotlinx.coroutines.scheduling.a:
    java.lang.String schedulerName -> g
    kotlinx.coroutines.scheduling.GlobalQueue globalBlockingQueue -> i
    kotlinx.coroutines.internal.Symbol NOT_IN_STACK -> o
    long idleWorkerKeepAliveNs -> f
    int corePoolSize -> d
    kotlinx.coroutines.internal.ResizableAtomicArray workers -> j
    int maxPoolSize -> e
    kotlinx.coroutines.scheduling.GlobalQueue globalCpuQueue -> h
    java.util.concurrent.atomic.AtomicLongFieldUpdater controlState$FU -> m
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater _isTerminated$FU -> n
    kotlinx.coroutines.scheduling.CoroutineScheduler$Companion Companion -> k
    java.util.concurrent.atomic.AtomicLongFieldUpdater parkedWorkersStack$FU -> l
    boolean addToGlobalQueue(kotlinx.coroutines.scheduling.Task) -> a
    int createNewWorker() -> b
    kotlinx.coroutines.scheduling.Task createTask(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext) -> c
    kotlinx.coroutines.scheduling.CoroutineScheduler$Worker currentWorker() -> d
    void dispatch(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean) -> e
    void dispatch$default(kotlinx.coroutines.scheduling.CoroutineScheduler,java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean,int,java.lang.Object) -> f
    int parkedWorkersStackNextIndex(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> g
    kotlinx.coroutines.scheduling.CoroutineScheduler$Worker parkedWorkersStackPop() -> h
    boolean parkedWorkersStackPush(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> i
    void parkedWorkersStackTopUpdate(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker,int,int) -> j
    void runSafely(kotlinx.coroutines.scheduling.Task) -> k
    void shutdown(long) -> l
    void signalBlockingWork(boolean) -> m
    void signalCpuWork() -> n
    kotlinx.coroutines.scheduling.Task submitToLocalQueue(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker,kotlinx.coroutines.scheduling.Task,boolean) -> o
    boolean tryCreateWorker(long) -> p
    boolean tryCreateWorker$default(kotlinx.coroutines.scheduling.CoroutineScheduler,long,int,java.lang.Object) -> q
    boolean tryUnpark() -> r
kotlinx.coroutines.scheduling.CoroutineScheduler$Companion -> kotlinx.coroutines.scheduling.a$a:
kotlinx.coroutines.scheduling.CoroutineScheduler$WhenMappings -> kotlinx.coroutines.scheduling.a$b:
    int[] $EnumSwitchMapping$0 -> a
kotlinx.coroutines.scheduling.CoroutineScheduler$Worker -> kotlinx.coroutines.scheduling.a$c:
    kotlinx.coroutines.scheduling.WorkQueue localQueue -> d
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState state -> e
    long terminationDeadline -> f
    boolean mayHaveLocalTasks -> i
    int rngState -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler this$0 -> j
    long minDelayUntilStealableTaskNs -> g
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater workerCtl$FU -> k
    kotlinx.coroutines.scheduling.CoroutineScheduler access$getThis$0$p(kotlinx.coroutines.scheduling.CoroutineScheduler$Worker) -> a
    void afterTask(int) -> b
    void beforeTask(int) -> c
    void executeTask(kotlinx.coroutines.scheduling.Task) -> d
    kotlinx.coroutines.scheduling.Task findAnyTask(boolean) -> e
    kotlinx.coroutines.scheduling.Task findTask(boolean) -> f
    int getIndexInArray() -> g
    java.lang.Object getNextParkedWorker() -> h
    void idleReset(int) -> i
    boolean inStack() -> j
    int nextInt(int) -> k
    void park() -> l
    kotlinx.coroutines.scheduling.Task pollGlobalQueues() -> m
    void runWorker() -> n
    void setIndexInArray(int) -> o
    void setNextParkedWorker(java.lang.Object) -> p
    boolean tryAcquireCpuPermit() -> q
    void tryPark() -> r
    boolean tryReleaseCpu(kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState) -> s
    kotlinx.coroutines.scheduling.Task trySteal(boolean) -> t
    void tryTerminateWorker() -> u
kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState -> kotlinx.coroutines.scheduling.a$d:
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState CPU_ACQUIRED -> d
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState BLOCKING -> e
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState PARKING -> f
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState DORMANT -> g
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState TERMINATED -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState[] $VALUES -> i
    kotlinx.coroutines.scheduling.CoroutineScheduler$WorkerState[] $values() -> a
kotlinx.coroutines.scheduling.DefaultIoScheduler -> kotlinx.coroutines.scheduling.b:
    kotlinx.coroutines.CoroutineDispatcher default -> g
    kotlinx.coroutines.scheduling.DefaultIoScheduler INSTANCE -> f
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
kotlinx.coroutines.scheduling.DefaultScheduler -> kotlinx.coroutines.scheduling.c:
    kotlinx.coroutines.scheduling.DefaultScheduler INSTANCE -> k
kotlinx.coroutines.scheduling.GlobalQueue -> kotlinx.coroutines.scheduling.d:
kotlinx.coroutines.scheduling.NanoTimeSource -> kotlinx.coroutines.scheduling.e:
    kotlinx.coroutines.scheduling.NanoTimeSource INSTANCE -> a
    long nanoTime() -> a
kotlinx.coroutines.scheduling.SchedulerCoroutineDispatcher -> kotlinx.coroutines.scheduling.f:
    java.lang.String schedulerName -> i
    long idleWorkerKeepAliveNs -> h
    kotlinx.coroutines.scheduling.CoroutineScheduler coroutineScheduler -> j
    int corePoolSize -> f
    int maxPoolSize -> g
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
    kotlinx.coroutines.scheduling.CoroutineScheduler createScheduler() -> n
    void dispatchWithContext$kotlinx_coroutines_core(java.lang.Runnable,kotlinx.coroutines.scheduling.TaskContext,boolean) -> o
kotlinx.coroutines.scheduling.SchedulerTimeSource -> kotlinx.coroutines.scheduling.g:
    long nanoTime() -> a
kotlinx.coroutines.scheduling.Task -> kotlinx.coroutines.scheduling.h:
    kotlinx.coroutines.scheduling.TaskContext taskContext -> e
    long submissionTime -> d
kotlinx.coroutines.scheduling.TaskContext -> kotlinx.coroutines.scheduling.i:
    int getTaskMode() -> a
    void afterTask() -> b
kotlinx.coroutines.scheduling.TaskContextImpl -> kotlinx.coroutines.scheduling.j:
    int taskMode -> a
    int getTaskMode() -> a
    void afterTask() -> b
kotlinx.coroutines.scheduling.TaskImpl -> kotlinx.coroutines.scheduling.k:
    java.lang.Runnable block -> f
kotlinx.coroutines.scheduling.TasksKt -> kotlinx.coroutines.scheduling.l:
    kotlinx.coroutines.scheduling.TaskContext BlockingContext -> g
    kotlinx.coroutines.scheduling.SchedulerTimeSource schedulerTimeSource -> e
    kotlinx.coroutines.scheduling.TaskContext NonBlockingContext -> f
    long WORK_STEALING_TIME_RESOLUTION_NS -> a
    long IDLE_WORKER_KEEP_ALIVE_NS -> d
    int CORE_POOL_SIZE -> b
    int MAX_POOL_SIZE -> c
kotlinx.coroutines.scheduling.UnlimitedIoScheduler -> kotlinx.coroutines.scheduling.m:
    kotlinx.coroutines.scheduling.UnlimitedIoScheduler INSTANCE -> e
    void dispatch(kotlin.coroutines.CoroutineContext,java.lang.Runnable) -> c
kotlinx.coroutines.scheduling.WorkQueue -> kotlinx.coroutines.scheduling.o:
    java.util.concurrent.atomic.AtomicReferenceFieldUpdater lastScheduledTask$FU -> b
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater blockingTasksInBuffer$FU -> e
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater consumerIndex$FU -> d
    java.util.concurrent.atomic.AtomicIntegerFieldUpdater producerIndex$FU -> c
    java.util.concurrent.atomic.AtomicReferenceArray buffer -> a
    kotlinx.coroutines.scheduling.Task add(kotlinx.coroutines.scheduling.Task,boolean) -> a
    kotlinx.coroutines.scheduling.Task add$default(kotlinx.coroutines.scheduling.WorkQueue,kotlinx.coroutines.scheduling.Task,boolean,int,java.lang.Object) -> b
    kotlinx.coroutines.scheduling.Task addLast(kotlinx.coroutines.scheduling.Task) -> c
    void decrementIfBlocking(kotlinx.coroutines.scheduling.Task) -> d
    int getBufferSize$kotlinx_coroutines_core() -> e
    int getSize$kotlinx_coroutines_core() -> f
    void offloadAllWorkTo(kotlinx.coroutines.scheduling.GlobalQueue) -> g
    kotlinx.coroutines.scheduling.Task poll() -> h
    kotlinx.coroutines.scheduling.Task pollBuffer() -> i
    boolean pollTo(kotlinx.coroutines.scheduling.GlobalQueue) -> j
    long tryStealBlockingFrom(kotlinx.coroutines.scheduling.WorkQueue) -> k
    long tryStealFrom(kotlinx.coroutines.scheduling.WorkQueue) -> l
    long tryStealLastScheduled(kotlinx.coroutines.scheduling.WorkQueue,boolean) -> m
kotlinx.coroutines.scheduling.WorkQueue$$ExternalSyntheticBackportWithForwarding0 -> kotlinx.coroutines.scheduling.n:
# {"id":"sourceFile","fileName":"R8$$SyntheticClass"}
# {"id":"com.android.tools.r8.synthesized"}
    boolean kotlinx.coroutines.scheduling.WorkQueue$$InternalSyntheticBackportWithForwarding$1$fea41a45c8396694b734bf6713722fe4232fc4db1f67f3f538fe971a17baaead$0.m(java.util.concurrent.atomic.AtomicReferenceArray,int,java.lang.Object,java.lang.Object) -> a
      # {"id":"com.android.tools.r8.synthesized"}
lombok.launch.AnnotationProcessorHider$AnnotationProcessor -> k0.a:
    javax.annotation.processing.AbstractProcessor instance -> a
    javax.annotation.processing.AbstractProcessor createWrappedInstance() -> a
lombok.launch.AnnotationProcessorHider$ClaimingProcessor -> k0.b:
lombok.launch.Main -> k0.c:
    lombok.launch.ShadowClassLoader classLoader -> a
    java.lang.ClassLoader getShadowClassLoader() -> a
lombok.launch.ShadowClassLoader -> k0.d:
    java.io.File SELF_BASE_FILE -> b
    java.util.concurrent.ConcurrentMap highlanderMap -> l
    java.util.Map mapTrackerToJarPath -> m
    java.util.Map mapTrackerToJarContents -> n
    int SELF_BASE_LENGTH -> c
    java.util.Set prependedParentLoaders -> h
    java.util.List parentExclusion -> f
    java.util.List override -> d
    java.util.Map mapJarPathToTracker -> i
    java.util.Map fileRootCache -> j
    java.lang.String SELF_BASE -> a
    java.util.Map jarLocCache -> k
    java.util.List highlanders -> g
    java.lang.String sclSuffix -> e
    void addOverrideClasspathEntry(java.lang.String) -> a
    void addOverrideJarDir(java.lang.String) -> b
    boolean exclusionListMatch(java.lang.String) -> c
    java.util.Set getJarMemberSet(java.lang.String) -> d
    java.util.Set getOrMakeJarListing(java.lang.String) -> e
    java.net.URL getResourceFromLocation(java.lang.String,java.lang.String,java.io.File) -> f
    java.net.URL getResourceSkippingSelf(java.lang.String) -> g
    java.net.URL getResource_(java.lang.String,boolean) -> h
    boolean inOwnBase(java.lang.String,java.lang.String) -> i
    boolean isPartOfShadowSuffix(java.lang.String,java.lang.String,java.lang.String) -> j
    boolean isPartOfShadowSuffixFileBased(java.lang.String,java.lang.String) -> k
    boolean isPartOfShadowSuffixJarBased(java.lang.String,java.lang.String) -> l
    boolean partOfShadow(java.lang.String,java.lang.String) -> m
    boolean sclFileContainsSuffix(java.io.InputStream,java.lang.String) -> n
    java.lang.String urlDecode(java.lang.String) -> o
    java.lang.Class urlToDefineClass(java.lang.String,java.net.URL,boolean) -> p
